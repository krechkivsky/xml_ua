# -*- coding: utf-8 -*-
"""
/***************************************************************************
 xml_uaDockWidget
                                 A QGIS plugin
 Processing ukrainian cadastral files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-01
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Mike
        email                : michael.krechkivski@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


# region Import
import os
import inspect
import copy

from lxml import etree

from qgis.PyQt import uic

from qgis.PyQt.QtGui import QIcon

from qgis.PyQt.QtCore import QModelIndex
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtCore import Qt

from qgis.core import Qgis
from qgis.core import QgsLayerTreeGroup
from qgis.core import QgsLayerTreeLayer
from qgis.core import QgsProject
from qgis.core import QgsLayerTreeModel

from qgis.gui import QgsLayerTreeView


from qgis.PyQt.QtWidgets import QDockWidget
from qgis.PyQt.QtWidgets import QWidget
from qgis.PyQt.QtWidgets import QVBoxLayout
from qgis.PyQt.QtWidgets import QHBoxLayout
from qgis.PyQt.QtWidgets import QMenu
from qgis.PyQt.QtWidgets import QAction
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.PyQt.QtWidgets import QToolButton
from qgis.PyQt.QtWidgets import QStyle
from qgis.PyQt.QtWidgets import QTreeView
from qgis.PyQt.QtWidgets import QFileDialog
from qgis.PyQt.QtWidgets import QTableView
from qgis.PyQt.QtWidgets import QInputDialog

from qgis.PyQt.QtWidgets import QTabWidget, QStyleOption, QWidget, QStyle, QPushButton, QTabBar
from qgis.PyQt.QtGui import QPainter, QIcon, QPalette
from qgis.PyQt.QtCore import QSettings

from .tree_view import CustomTreeView
from .metadata import TableViewMetadata
from .parcel import TableViewParcel
from .layers import xmlUaLayers

from .common import logFile
from .common import log_msg
from .common import log_calls
from .common import xsd_path
from .common import connector
from .common import geometry_to_string
from .common import size
# endregion


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'xml_ua_dockwidget_base.ui'))


class xml_uaDockWidget(QDockWidget, FORM_CLASS):


    closingPlugin = pyqtSignal()




    def __init__(self, parent=None, iface=None, plugin=None):

        # parent -> QMainWindow
        # виконується лише після відкриття файла -> ❓❓❓

        # log_calls(logFile)

        super().__init__(parent)

        # інтерфейс QGIS
        self.iface = iface

        # Підключити нову модель до дерева шарів
        # layer_tree_view = iface.layerTreeView()
        # log_msg(logFile, f"layer_tree_view: {layer_tree_view}")
        # custom_model = self.CustomLayerTreeModel(QgsProject.instance().layerTreeRoot())
        # log_msg(logFile, f"custom_model: {custom_model}")
        # layer_tree_view.setModel(custom_model)
        
        self.plugin = plugin
        # Читаємо дизайн UI з файлу xml_ua_dockwidget_base.ui
        self.setupUi(self)
        self.parent = parent

        # Створюємо пустий список відкритих xml-файлів
        self.opened_xmls = []

        # ініціалізація атрибутів
        self.full_xml_file_name = None
        self.layers_obj = None
        self.full_xml_file_name = ""

        # Флаг для блокування рекурсивних викликів при закритті
        self._is_closing = False

        # Налаштування QTabWidget
        self.tabWidget.setMovable(True)
        self.tabWidget.setTabsClosable(False) # Вимикаємо стандартні кнопки
        # Видаляємо початкові вкладки, створені з .ui файлу
        while self.tabWidget.count() > 0:
            self.tabWidget.removeTab(0)

        # для створення списку відкритих xml-файлів
        # потрібно отримати кореневий елемент дерева шарів QGIS
        self.layers_root = QgsProject.instance().layerTreeRoot()

        self.setWindowTitle("xml_ua")

        # Створюємо об'єкт даних xml, який відображається у доквіджеті
        # self.current_xml = self.xml_data(path="", tree=None, group_name=None)

        # Тут лише ініціалізуємо змінну current_xml
        # Створювати об'єкт xml_data будемо при відкритті файлу 
        # або при cтворенні нового xml
        self.current_xml = None

        # Сигнали для вкладок
        connector.connect(self.tabWidget, "tabCloseRequested", self.close_tab)
        connector.connect(self.tabWidget, "currentChanged", self.on_tab_changed)

        # Підключаємо сигнали дерева шарів
        self.connect_layer_tree_signals()
        connector.connect(self.layers_root, "nodeRemoved", self.on_node_removed)



    class xml_data:


        # Всередині класу xml_data створюємо клас xml_geometry
        # для зберігання "старої" геометрії XML, яка недоступна
        # у сигналах QGIS по зміні геометрії


        class xml_geometry:
            """
            Клас для зберігання геометрії XML.
            """

            # Конструктор класу xml_geometry
            def __init__(self, geometry: str = ""):
                self.points = []
                self.lines = []
                self.zone = None
                self.quarter = None
                self.parcel = None
                self.lands = []
                self.leases = []
                self.subleases = []
                self.restrictions = []
                self.adjacents = []


        # Конструктор класу xml_data
        def __init__(self, path: str = "", tree: object = None, group_name: str = ""):  # Змінено
            self.path = path
            self.tree = tree
            self.group_name = group_name
            self.geom = self.xml_geometry()
            self.changed = False


        def __deepcopy__(self, memo):
            """
            Deep copy implementation for xml_data objects.
            """
            cls = self.__class__
            result = cls.__new__(cls)
            memo[id(self)] = result
            for k, v in self.__dict__.items():
                if k == "tree":
                    setattr(result, k, copy.deepcopy(v, memo))
                else:
                    setattr(result, k, copy.deepcopy(v, memo))
            return result


    def connect_layer_tree_signals(self):
        """Підключає сигнали від дерева шарів до слотів цього віджета."""
        log_calls(logFile, "Підключення сигналів дерева шарів.")
        connector.connect(self.iface.layerTreeView(), "doubleClicked", self.double_clicked)
        connector.connect(self.iface.layerTreeView(), "clicked", self.clicked)


    def disconnect_layer_tree_signals(self):
        """Відключає сигнали від дерева шарів."""
        log_calls(logFile, "Відключення сигналів дерева шарів.")
        connector.disconnect(self.iface.layerTreeView(), "doubleClicked", self.double_clicked)
        connector.disconnect(self.layers_root, "nodeRemoved", self.on_node_removed)
        connector.disconnect(self.iface.layerTreeView(), "clicked", self.clicked)

    def load_data(self, xml_path, tree = None):

        # При виклику з process_group_click tree != None
        # При виклику з process_action_open tree == None

        # log_calls(logFile, f"xml_path = {xml_path}\ntree = {tree}")

        # Знаходимо поточну вкладку та її дерево
        current_tab_widget = self.tabWidget.currentWidget()
        if not current_tab_widget: return
        tree_view = current_tab_widget.findChild(CustomTreeView)
        if not tree_view: return

        tree_view.load_xml_to_tree_view(xml_path, xsd_path, tree)
        self.current_xml.tree = tree_view.xml_tree

        return


    def process_action_check(self):
        """Перевіряє поточний активний XML-файл."""
        if not self.current_xml:
            QMessageBox.warning(self, "Помилка", "Немає активного XML-файлу для перевірки.")
            return

        log_msg(logFile, f"Обробка події перевірки файлу XML: {self.current_xml.path}")

        # level= Qgis.Success, Qgis.MessageLevel, Qgis.Info, Qgis.Warning, Qgis.Critical
        # duration sec 0 - до закриття
        self.iface.messageBar().pushMessage("xml_ua:", f"Перевірка файлу: {os.path.basename(self.current_xml.path)}", level=Qgis.Info, duration=5)
        QMessageBox.warning(self, "xml_ua:", "Вихід")
        self.handle_error_and_close("Обробка події перевірки файлу XML")


    def process_action_open(self):
        
        """
        Handles the action of opening an XML file.
        This method performs the following steps:
        1. Logs the action.
        2. Closes all tabs except "Структура", "Реквізити", and "Ділянка".
        3. Clears existing data in TreeView and TableViews.
        4. Opens a file dialog to select an XML file.
        5. If no file is selected, shows a warning message and exits.
        6. Sets the window title to the selected file's name.
        7. Loads data from the selected XML file.
        8. Expands initial elements in the TreeView and sets the column width.
        9. Retrieves the layers_obj name from the XML layers and logs it.
        Returns:
            None
        """

        # log_calls(logFile)

        # region відкриваємо файл XML

        xml_path, _ = QFileDialog.getOpenFileName(
            self, "Відкрити XML файл", "", "XML файли (*.xml)")

        if not xml_path:
            QMessageBox.warning(self, "Помилка", "Файл не вибрано.")
            return

        # Тому треба перевірити файл на відповідність структурі xml
        # це: наявність кореневого елемента, обов'язкових елементів
        # відповіденість відкритих тегів закритим, відповідність атрибутів
        # TODO: тут поки неповна шивка перевірка
        if not self.validate_xml_structure(xml_path):
            # TODO: тут треба виводити помилку на панелі QGIS - 
            # чому саме validate_xml_structure видала False
            # для цього її логіка роботи: визначення помилок
            # замість validate_xml_structure вона повинна 
            # називатися errors_list ==> [] якщо все ок
            log_msg(logFile, "Неправильна структура файлу XML.")
            # Виводимо попередження про помилку на панелі QGIS
            self.iface.messageBar().pushMessage(
                                "xml_ua:", 
                                "Неправильна структура файлу XML.", 
                                level=Qgis.Critical, 
                                duration=0)
            
            return
        else:
            # log_msg(logFile, "Файл відповідає структурі XML.")
            # Виводимо повідомлення про успіх на панелі QGIS
            self.iface.messageBar().pushMessage(
                                "xml_ua:", 
                                "Файл відповідає структурі XML.", 
                                level=Qgis.Success, 
                                duration=5)
            pass
        # endregion

        # Створюємо новий об'єкт xml_data
        new_xml_data = self.xml_data(path=xml_path, tree=None, group_name="")
        self.current_xml = new_xml_data

        # Створюємо нову вкладку
        new_tab = QWidget()
        layout = QVBoxLayout(new_tab)
        tree_view = CustomTreeView(parent=self)
        layout.addWidget(tree_view)
        new_tab.setLayout(layout)

        # Додаємо вкладку
        index = self.tabWidget.addTab(new_tab, os.path.basename(xml_path))
        self.tabWidget.setCurrentIndex(index)

        # Зберігаємо посилання на дерево у об'єкті xml_data
        self.current_xml.tree_view = tree_view

        # Завантажуємо дані
        self.load_data(xml_path, tree=None)

        # Оновлюємо дерево
        tree_view.expand_initial_elements()
        tree_view.set_column_width(0, 75)

        # ініціалізуємо заповнення шарів
        self.layers_obj = xmlUaLayers(xml_path, self.current_xml.tree, plugin=self.plugin) # Pass self.plugin
        self.current_xml.group_name = self.layers_obj.group.name()

        # Оновлюємо назву вкладки на назву групи
        self.tabWidget.setTabText(index, self.current_xml.group_name)
        self.tabWidget.setTabToolTip(index, xml_path)
        self.setup_custom_tab_buttons() # Оновлюємо кнопки
        self.opened_xmls.append(self.current_xml)

        return


    def log_opened_xmls(self):
        """
        Logs the opened XML files.
        """        
        # Ця логіка більше не потрібна в такому вигляді
        pass


    def process_action_new(self, tree):
        """
        """
        # Процес створення нового xml
        # У цьому місці користувач вибравши пункт 
        # меню "Новий" вибрав папку і назву файлу 
        # шаблон зчитаний і розпарсений ???
        # треба зберегти дерево xml на диск і відкрити 
        # відкрити його без перевіоки наявності всіх
        # обов'язкових елементів схеми оскільки файл
        # у процесі розробки
        
        log_calls(logFile)

        xml_path = self.plugin.new_xml
        if not xml_path:
            return

        # Створюємо новий об'єкт xml_data
        new_xml_data = self.xml_data(path=xml_path, tree=tree, group_name="")
        self.current_xml = new_xml_data

        # Створюємо нову вкладку
        new_tab = QWidget()
        layout = QVBoxLayout(new_tab)
        tree_view = CustomTreeView(parent=self)
        layout.addWidget(tree_view)
        new_tab.setLayout(layout)

        # Додаємо вкладку
        index = self.tabWidget.addTab(new_tab, os.path.basename(xml_path))
        self.tabWidget.setCurrentIndex(index)

        # Зберігаємо посилання на дерево у об'єкті xml_data
        self.current_xml.tree_view = tree_view

        # Завантажуємо дані
        self.load_data(xml_path, tree=tree)

        # Оновлюємо дерево
        tree_view.expand_initial_elements()
        tree_view.set_column_width(0, 75)

        # ініціалізуємо заповнення шарів
        self.layers_obj = xmlUaLayers(xml_path, self.current_xml.tree, plugin=self.plugin)
        self.current_xml.group_name = self.layers_obj.group.name()

        # Оновлюємо назву вкладки на назву групи
        self.tabWidget.setTabText(index, self.current_xml.group_name)
        self.tabWidget.setTabToolTip(index, xml_path)
        self.setup_custom_tab_buttons() # Оновлюємо кнопки
        self.opened_xmls.append(self.current_xml)
        
        self.current_xml.path = xml_path
        self.update_window_title(self.current_xml.path)

        return


    def resizeEvent(self, event):
        """
        Оновлює заголовок віджета при зміні розміру віджета.
        """
        super().resizeEvent(event)
        self.update_window_title(self.full_xml_file_name)


    def update_window_title(self, file_name):
        """
        Оновлює заголовок віджета, враховуючи доступну ширину та 
        обрізаючи назву файлу, якщо потрібно.
        """
        self.setWindowTitle("xml_ua")
    def mark_as_changed(self):
        """
        Позначає поточний XML-файл як змінений і оновлює заголовок вікна.
        """
        # Ця логіка тепер обробляється у CustomTreeView
        pass

    def process_action_save(self):
        """Зберігає вибраний XML-файл."""
        log_calls(logFile, "Спроба зберегти XML.")

        xml_to_save = self.select_xml_to_save("Вибір групи для збереження")
        if not xml_to_save:
            return  # Користувач скасував або виникла помилка

        # Запитуємо підтвердження у користувача
        reply = QMessageBox.question(self, 'Підтвердження збереження',
                                     f"Зберегти зміни для групи '{xml_to_save.group_name}' у файл:\n\n{xml_to_save.path}?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            # Зберігаємо дерево вибраного XML
            xml_to_save.tree_view.save_xml_tree(xml_to_save.tree, xml_to_save.path)
            self.iface.messageBar().pushMessage("Успіх", f"Файл збережено: {xml_to_save.path}", level=Qgis.Success, duration=5)
            log_msg(logFile, f"Файл збережено: {xml_to_save.path}")

            # Позначаємо, що зміни збережено
            xml_to_save.changed = False
            # Оновлюємо заголовок, якщо зберегли активний файл
            if xml_to_save == self.current_xml:
                self.update_window_title(xml_to_save.path)
        else:
            log_msg(logFile, "Збереження скасовано користувачем.")

    def process_action_save_as(self):
        """Зберігає вибраний XML-файл як новий файл."""
        log_calls(logFile, "Спроба зберегти XML як...")

        xml_to_save = self.select_xml_to_save("Вибір групи для збереження як")
        if not xml_to_save:
            return  # Користувач скасував або виникла помилка

        # Запитуємо у користувача шлях для збереження нового XML файлу
        save_path, _ = QFileDialog.getSaveFileName(self, "Зберегти XML файл як...", xml_to_save.path, "XML файли (*.xml)")
        if not save_path:
            log_msg(logFile, "Шлях для збереження не вибрано.")
            return

        # Запитуємо підтвердження у користувача
        reply = QMessageBox.question(self, 'Підтвердження збереження',
                                     f"Зберегти групу '{xml_to_save.group_name}' у новий файл:\n\n{save_path}?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            # Зберігаємо дерево вибраного XML за новим шляхом
            xml_to_save.tree_view.save_xml_tree(xml_to_save.tree, save_path)
            self.iface.messageBar().pushMessage("Успіх", f"Файл збережено: {save_path}", level=Qgis.Success, duration=5)
            log_msg(logFile, f"Файл збережено як: {save_path}")

            # Оновлюємо шлях у поточного об'єкта та заголовок
            xml_to_save.path = save_path
            xml_to_save.changed = False
            # Оновлюємо заголовок, якщо зберегли активний файл
            if xml_to_save == self.current_xml:
                self.update_window_title(xml_to_save.path)
        else:
            log_msg(logFile, "Збереження скасовано користувачем.")

    def select_xml_to_save(self, title: str):
        """
        Визначає, який XML-файл зберегти. Якщо відкрито більше одного,
        показує діалог вибору.
        """
        count = self.tabWidget.count()
        if count == 0:
            QMessageBox.warning(self, "Помилка", "Немає відкритих XML-файлів для збереження.")
            return None

        if count > 1:
            tab_names = [self.tabWidget.tabText(i) for i in range(count)]
            current_tab_index = self.tabWidget.currentIndex()

            tab_to_save, ok = QInputDialog.getItem(self, title,
                                                     "Виберіть вкладку, яку потрібно зберегти:",
                                                     tab_names, current_tab_index, False)
            if not ok or not tab_to_save:
                log_msg(logFile, "Збереження скасовано користувачем (вибір вкладки).")
                return None

            for i in range(count):
                if self.tabWidget.tabText(i) == tab_to_save:
                    return self.get_xml_data_for_tab_index(i)
        elif count == 1:
            return self.get_xml_data_for_tab_index(0)

        return None

    #def process_action_close_xml(self, xml_to_close=None):
    def process_action_close_xml(self, xml_to_close=None, group_already_removed=False):
        """Закриває вказаний або поточний XML-файл та пов'язану з ним групу шарів."""
        if self._is_closing:
            return
        self._is_closing = True

        #if xml_to_close is None:
        #    xml_to_close = self.current_xml

        if not xml_to_close:
            QMessageBox.warning(self, "Помилка", "Немає активного файлу для закриття.")
            self._is_closing = False
            return

        # Попереджаємо про незбережені зміни
        if xml_to_close.changed:
            reply = QMessageBox.question(self, 'Підтвердження закриття',
                                         f"Файл для групи '{xml_to_close.group_name}' має незбережені зміни. \n\nЗакрити без збереження?",
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.No:
                self._is_closing = False
                return

        ## 1. Знаходимо та видаляємо групу шарів, якщо вона ще не видалена
        #if not group_already_removed:
        #    group_to_remove = self.layers_root.findGroup(xml_to_close.group_name)
        #    if group_to_remove:
        #        self.layers_root.removeChildNode(group_to_remove)
        #        log_msg(logFile, f"Групу '{xml_to_close.group_name}' та її шари видалено.")

        # 1. Знаходимо та видаляємо групу шарів, якщо вона ще не видалена
        if not group_already_removed:
            group_to_remove = self.layers_root.findGroup(xml_to_close.group_name)
            if group_to_remove:
                self.layers_root.removeChildNode(group_to_remove)
                log_msg(logFile, f"Групу '{xml_to_close.group_name}' та її шари видалено.")




        # 2. Видаляємо зі списку відкритих XML
        if xml_to_close in self.opened_xmls:
            self.opened_xmls.remove(xml_to_close)
            log_msg(logFile, f"Файл '{xml_to_close.path}' видалено зі списку відкритих.")

        # 3. Видаляємо вкладку
        for i in range(self.tabWidget.count()):
            if self.tabWidget.tabText(i) == xml_to_close.group_name:
                self.tabWidget.removeTab(i)
                break

    def get_tooltip_from_tree(self, full_path, default_name):
        """
        Отримує tooltip для елемента з дерева за його шляхом.
        Якщо tooltip не знайдено, повертає default_name.
        """
        # log_msg(logFile)  # recursion
        current_tab_widget = self.tabWidget.currentWidget()
        if current_tab_widget:
            tree_view = current_tab_widget.findChild(CustomTreeView)
            if tree_view:
                return tree_view.get_tooltip_from_tree(full_path, default_name)
        return default_name # Fallback


    def find_element_index(self, path=None, element_name=None):
        """
        Знаходить індекс елемента у дереві на основі шляху або імені.
        """
        # log_msg(logFile) # recursion
        current_tab_widget = self.tabWidget.currentWidget()
        if current_tab_widget:
            tree_view = current_tab_widget.findChild(CustomTreeView)
            if tree_view:
                return tree_view.find_element_index(path, element_name)
        return QModelIndex() # Fallback


    def handle_error_and_close(self, error_message):
        """
            Обробляє помилку, відображає повідомлення і закриває док-віджет.

            Аргументи:
                Текст повідомлення про помилку.
        """
        log_msg(logFile)

        self.parent.iface.messageBar().pushCritical("Помилка", error_message)
        self.close()



    def showEvent(self, event):
        """ 
            Відновлення вкладок при відкритті вікна 

        """
        # Обробка події показу віджета.
        # Подія виникає, перед тим як віджет стає видимим.

        # log_calls(logFile, f"event = {event}")

        super().showEvent(event)


    def close_tab(self, index):
        """
        Handle tab close events.
        """
        xml_data = self.get_xml_data_for_tab_index(index)
        if xml_data:
            self.process_action_close_xml(xml_data)

    def setup_custom_tab_buttons(self):
        """
        Налаштовує кастомні кнопки закриття для всіх динамічних вкладок.
        """
        # Використовуємо стандартну, але меншу іконку
        close_icon = self.style().standardIcon(QStyle.SP_DockWidgetCloseButton)
        tab_bar = self.tabWidget.tabBar()

        for i in range(self.tabWidget.count()):
            # Перевіряємо, чи кнопка вже існує
            if tab_bar.tabButton(i, QTabBar.RightSide) is not None:
                continue

            tab_button = QPushButton(close_icon, "")
            tab_button.setFlat(True)
            tab_button.setCursor(Qt.ArrowCursor)
            # Встановлюємо фіксований розмір, щоб уникнути розтягування
            tab_button.setFixedSize(16, 16)
            tab_button.setStyleSheet("""
                QPushButton {
                    border: none;
                    background: transparent;
                    padding: 0px;
                }
                QPushButton:hover {
                    background-color: #d3d3d3; /* lightgray */
                    border-radius: 2px;
                }
                QPushButton:pressed {
                    background-color: #a9a9a9; /* darkgray */
                }
            """)
            # Використовуємо lambda, щоб передати правильний індекс вкладки
            tab_button.clicked.connect(lambda _, idx=i: self.close_tab(idx))
            tab_bar.setTabButton(i, QTabBar.RightSide, tab_button)


    def on_node_removed(self, node, parent):
        """Обробляє сигнал видалення вузла з дерева шарів."""
        if self._is_closing:
            return

        if isinstance(node, QgsLayerTreeGroup):
            group_name = node.name()
            # Перевіряємо, чи видалена група належить нашому плагіну
            xml_data_to_close = next((xml for xml in self.opened_xmls if xml.group_name == group_name), None)
            if xml_data_to_close:
                log_msg(logFile, f"Виявлено видалення групи '{group_name}'. Закриваємо відповідну вкладку.")
                # Викликаємо закриття, але без видалення групи, бо її вже немає
                self.iface.messageBar().pushMessage(
                    "xml_ua", f"Групу '{group_name}' видалено. Закриваємо відповідну вкладку.", level=Qgis.Info, duration=5
                )
                # Викликаємо закриття, але з прапорцем, що група вже видалена
                self.process_action_close_xml(xml_data_to_close, group_already_removed=True)


    def on_tab_changed(self, index):
        """Синхронізує активну вкладку з деревом шарів."""
        if index == -1: # Немає активних вкладок
            self.current_xml = None
            return

        xml_data = self.get_xml_data_for_tab_index(index)
        if xml_data:
            self.current_xml = xml_data
            group = self.layers_root.findGroup(xml_data.group_name)
            if group:
                self.iface.layerTreeView().setCurrentNode(group)
            self.update_window_title(xml_data.path)

    def update_tab_indices(self):
        """
        Оновлює індекси вкладок після закриття.
        """

        log_calls(logFile)
        # Ця логіка більше не потрібна, оскільки кнопки закриття стандартні

    def generate_layers_obj_name(self, base_name):
        """
        Формує назву групи на основі базової назви, додаючи суфікс, якщо група з такою назвою вже існує.

        Args:
            base_name (str): Базова назва групи (назва файлу без розширення).

        Returns:
            str: Назва групи.
        """
        layers_obj_name = base_name
        suffix = 0

        while self.layers_root.findGroup(layers_obj_name):
            suffix += 1
            layers_obj_name = f"{base_name}#{suffix}"

        return layers_obj_name


    def double_clicked(self, index):
        """
        Обробляє подвійне клацання на елементі в дереві шарів.
        """
        log_calls(logFile)

        # Отримуємо QgsLayerTreeNode, використовуючи QgsLayerTreeView
        item = self.iface.layerTreeView().index2node(index)

        if item is None:
            log_msg(logFile, f"item is None")
            return

        # log_msg(logFile, f"item.name() = {item.name()}")

        if isinstance(item, QgsLayerTreeGroup):
            layers_obj_name = item.name()
            log_msg(
                logFile, f"layers_obj_name = {layers_obj_name}")


    def clicked(self, index):
        """
        Обробляє  клацання на елементі в дереві шарів.
        """
        # (logFile, f"index = {index}")

        # Отримуємо QgsLayerTreeNode, використовуючи QgsLayerTreeView
        item = self.iface.layerTreeView().index2node(index)

        if item is None:
            log_msg(logFile, f"item is None")
            return

        if isinstance(item, QgsLayerTreeGroup):
            self.process_group_click(item.name())

        # Якщо елемент не група, то обробляємо його, то 
        # знаходимо його групу:
        if isinstance(item, QgsLayerTreeLayer):
            # log_msg(logFile, f"Клік на шарі {item.name()}")
            # Отримуємо групу шару
            group = self.find_parent_group(item)
            if group:
                group_name = group.name()
                # log_msg(logFile, f"Шар '{item.name()}' знаходиться в групі '{group_name}'")
                self.process_group_click(group_name)
            else:
                # log_msg(logFile, f"Шар '{item.name()}' не належить до жодної групи")
                pass

    def find_parent_group(self, item: QgsLayerTreeLayer) -> QgsLayerTreeGroup:
        """
        Finds the parent group of a given QgsLayerTreeLayer item.

        This method traverses the parent hierarchy of the provided QgsLayerTreeLayer
        to locate and return the first QgsLayerTreeGroup it belongs to. If no parent
        group is found, the method returns None.

        Args:
            item (QgsLayerTreeLayer): The layer tree item for which the parent group
                                      is to be found.

        Returns:
            QgsLayerTreeGroup: The parent group of the given item, or None if no
                               parent group exists.
        """
        parent = item.parent()
        while parent:
            if isinstance(parent, QgsLayerTreeGroup):
                return parent
            parent = parent.parent()
        return None

    def get_xml_data_for_tab_index(self, index):
        """Повертає об'єкт xml_data для вкладки за її індексом."""
        if index < 0 or index >= self.tabWidget.count():
            return None
        
        tab_name = self.tabWidget.tabText(index)
        # Ми припускаємо, що назва вкладки - це group_name
        for xml_data in self.opened_xmls:
            if xml_data.group_name == tab_name:
                return xml_data
        return None

    def validate_xml_structure(self, xml_path):

        #✔️ 2025.04.03 08:59
        # Перевіряти треба xml при відкритті і шаблони при створенні, бо
        # користувач може зробити помилку у шаблоні 
        # Це часткова перевірка структури XML
        # Повна перевірка структури XML засобами library lxml
        # не працює, бо ВСІ файли не відповідають схемі XSD
        # у майбутньому треба розширити перевірку
        # з врахуванням того, що файл може бути у процесі розробки

        #✔️ 2025.04.03  
        # log_msg(logFile)

        # Список обов'язкових елементів
        mandatory_elements = [
            "AdditionalPart",
            "ServiceInfo",
            "FileID",
            "FormatVersion",
            "FileDate",
            "FileGUID",
            "ReceiverName",
            "ReceiverIdentifier",
            "Software",
            "SoftwareVersion",
            "InfoLandWork",
            "Executor",
            "CompanyName",
            "Chief",
            "Address",
            "InfoPart",
            "MetricInfo",
            "CoordinateSystem",
            "HeightSystem",
            "MeasurementUnit",
            "PointInfo",
            "Polyline",
            "ControlPoint",
            "CadastralZoneInfo",
            "CadastralZoneNumber",
            "CadastralQuarterInfo",
            "CadastralQuarterNumber",
            "ParcelInfo",
            "ParcelMetricInfo"
        ]
        try:
            # 1. Parse the XML (Well-Formedness Check)
            tree = etree.parse(xml_path)
            root = tree.getroot()

            # 2. Check for a Root Element
            if root is None:
                log_msg(logFile, "Error: No root element found in the XML file.")
                return False

            # Check if the root element's tag is 'UkrainianCadastralExchangeFile'
            if root.tag != "UkrainianCadastralExchangeFile":
                log_msg(
                    logFile, f"Error: Root element is '{root.tag}', expected 'UkrainianCadastralExchangeFile'.")
                return False

            for element_name in mandatory_elements:
                element = root.find(".//" + element_name)
                if element is None:
                    log_msg(
                        logFile, f"Error: Mandatory element '{element_name}' is missing.")
                    return False
        except Exception as e:
            log_msg(logFile, f"Error during XML structure validation: {e}")
            return False

        return True


    def process_group_click(self, group_name):
        """
        Handles the event when a group in the QGIS layer tree is clicked.

        This method synchronizes the dock widget with the selected group in the 
        QGIS layer tree. It ensures that the corresponding XML data for the group 
        is loaded and displayed in the dock widget.

        Args:
            group_name (str): The name of the group clicked in the QGIS layer tree.

        Behavior:
            - Logs the group click event.
            - Checks if the 'opened_xmls' attribute is initialized. If not, displays 
              a warning message and logs an error.
            - Searches for the clicked group in the QGIS layer tree. If not found, 
              logs an error and exits.
            - Searches for the corresponding XML data in the 'opened_xmls' list. If 
              not found, logs a message and exits.
            - If the dock widget is hidden, it is shown.
            - Clears the dock widget's data and loads the XML data associated with 
              the clicked group.
            - Configures the appearance of the XML tree view in the dock widget.
            - Updates the dock widget's title to reflect the current XML file path.

        Raises:
            None
        """


        # Основна мета — синхронізувати доквіджет з вибраною групою 
        # в дереві шарів QGIS коли користувач клацає групу, 

        # log_calls(logFile, group_name)

        # Знаходимо відповідну вкладку
        for i in range(self.tabWidget.count()):
            if self.tabWidget.tabText(i) == group_name:
                # Переключаємось на вкладку, це викличе on_tab_changed
                if self.tabWidget.currentIndex() != i:
                    self.tabWidget.setCurrentIndex(i)
                else: # Якщо вкладка вже активна, просто оновлюємо дані
                    self.current_xml = self.get_xml_data_for_tab_index(i)
                    self.update_window_title(self.current_xml.path)
                break


    def update_xml_with_new_geometry(self, layer, feature_id, geometry):
        """
        Оновлює XML-файл на основі нової геометрії.
        """
        # log_calls(logFile, f"layer: {layer.name()}, feature_id: {feature_id}, geometry: {geometry}")
        log_calls(logFile)

        # Отримуємо фічу за її ID
        feature = layer.getFeature(feature_id)
        if not feature:
            log_msg(logFile, f"Фіча з ID {feature_id} не знайдена в шарі {layer.name()}.")
            return

        # Отримуємо геометрію фічі
        new_geometry = feature.geometry()
        log_calls(logFile, f"Нова геометрія фічі: {geometry_to_string(new_geometry)}")

        # TODO: Тут потрібно додати логіку для оновлення 
        # XML-файлу на основі нової геометрії
        QMessageBox.information(self, "update_xml_with_new_geometry()", f"Нова геометрія фічі: {geometry_to_string(new_geometry)}")




    # def customize_layer_tree_context_menu(self, point):
    #     """
    #     Customizes the layerTreeView context menu, removing or disabling the "Rename Group" item.
    #     """
    #     log_calls(logFile, f"point = {point}")
    #     QMessageBox.information(self, "customize_layer_tree_context_menu()", f"point = {point}")


    #     try:
    #         # Get the layerTreeView
    #         layer_tree_view = self.iface.layerTreeView()

    #         # Get the index of the item where the right-click occurred
    #         index = layer_tree_view.indexAt(point)

    #         # Check if the click was on a valid item
    #         if not index.isValid():
    #             return

    #         # Get the layer tree model
    #         model = layer_tree_view.model()

    #         # Get the layer tree node
    #         node = model.nodeFromIndex(index)

    #         # Create a new context menu
    #         menu = QMenu()

    #         # Add the default actions to the menu
    #         actions = layer_tree_view.contextMenuActions(index)
    #         for action in actions:
    #             menu.addAction(action)

    #         # Remove or disable the "Rename Group" item
    #         for action in menu.actions():
    #             if action.text() == "Перейменувати групу":  # "Rename Group" in Ukrainian
    #                 if isinstance(node, QgsLayerTreeGroup):
    #                     # Remove the menu item
    #                     menu.removeAction(action)
    #                     # Or disable the menu item:
    #                     # action.setEnabled(False)
    #                 break

    #         # Show the menu
    #         menu.exec_(layer_tree_view.mapToGlobal(point))

    #     except Exception as e:
    #         log_calls(logFile, f"Error customizing context menu: {e}")
