# -*- coding: utf-8 -*-
"""
/***************************************************************************
 xml_uaDockWidget
                                 A QGIS plugin
 Processing ukrainian cadastral files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-01
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Mike
        email                : michael.krechkivski@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import inspect
import copy

from lxml import etree

from qgis.PyQt import uic

from qgis.PyQt.QtGui import QIcon

from qgis.PyQt.QtCore import QModelIndex
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtCore import Qt

from qgis.core import Qgis
from qgis.core import QgsLayerTreeGroup
from qgis.core import QgsProject

from qgis.PyQt.QtWidgets import QDockWidget
from qgis.PyQt.QtWidgets import QWidget
from qgis.PyQt.QtWidgets import QVBoxLayout
from qgis.PyQt.QtWidgets import QHBoxLayout
from qgis.PyQt.QtWidgets import QMenu
from qgis.PyQt.QtWidgets import QAction
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.PyQt.QtWidgets import QToolButton
from qgis.PyQt.QtWidgets import QStyle
from qgis.PyQt.QtWidgets import QTreeView
from qgis.PyQt.QtWidgets import QFileDialog
from qgis.PyQt.QtWidgets import QTableView

from qgis.PyQt.QtWidgets import QTabWidget, QStyleOption, QWidget, QStyle, QPushButton, QTabBar
from qgis.PyQt.QtGui import QPainter, QIcon, QPalette
from qgis.PyQt.QtCore import QSettings

from .tree_view import CustomTreeView
from .metadata import TableViewMetadata
from .parcel import TableViewParcel
from .layers import xmlUaLayers

from .common import logFile
from .common import log_msg
from .common import log_calls
from .common import xsd_path
from .common import connector
from .common import geometry_to_string


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'xml_ua_dockwidget_base.ui'))


class xml_uaDockWidget(QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None, plugin=None):

        # тип parent QMainWindow
        # виконується лише після відкриття файла

        # log_calls(logFile, f"\nparent: {parent}\nplugin: {plugin}")

        super().__init__(parent)

        self.iface = plugin.iface  # add iface to class

        connector.connect(self.iface.layerTreeView(), "doubleClicked", self.double_clicked)
        connector.connect(self.iface.layerTreeView(), "clicked", self.clicked)

        self.plugin = plugin
        # Читаємо дизайн UI з файлу xml_ua_dockwidget_base.ui
        self.setupUi(self)
        self.parent = parent

        # Створюємо пустий список відкритих xml-файлів
        self.opened_xmls = []

        # ініціалізація атрибутів
        self.full_xml_file_name = None
        # Завантажуємо налаштування віджета з реєстру Windows
        self.closed_tabs = []
        # ?
        self.layers_obj = None
        self.full_xml_file_name = ""
        self.tabWidget.setTabsClosable(True)

        # для створення списку відкритих xml-файлів
        # потрібно отримати кореневий елемент дерева шарів QGIS
        self.layers_root = QgsProject.instance().layerTreeRoot()

        old_tree_view = self.findChild(QTreeView, "treeViewXML")
        self.treeViewXML = CustomTreeView(parent=self)
        if old_tree_view:
            layout = self.tabXML.layout()
            if layout:
                layout.removeWidget(old_tree_view)
            old_tree_view.setParent(None)
            old_tree_view.deleteLater()
        self.treeViewXML.setObjectName("treeViewXML")
        self.tabXML.layout().addWidget(self.treeViewXML)

        old_table_view = self.findChild(QTableView, "tableViewMetadata")
        if old_table_view:
            layout = self.tabMetadata.layout()
            if layout:
                layout.removeWidget(old_table_view)
            old_table_view.setParent(None)
            old_table_view.deleteLater()
        self.tableViewMetadata = TableViewMetadata(parent=self)  # ✅
        self.tableViewMetadata.setObjectName(
            "tableViewMetadata")  # Залишаємо те саме ім'я
        self.tableViewMetadata.horizontalHeader().setStretchLastSection(True)
        self.tabMetadata.layout().addWidget(self.tableViewMetadata)  # Додаємо до layout

        old_parcel_view = self.findChild(QTableView, "tableViewParcel")
        if old_parcel_view:
            layout = self.tabParcel.layout()
            if layout:
                layout.removeWidget(old_table_view)
                layout.removeWidget(old_parcel_view)
            old_parcel_view.setParent(None)
            old_parcel_view.deleteLater()
        self.tableViewParcel = TableViewParcel(parent=self)
        self.tableViewParcel.setObjectName("tableViewParcel")
        self.tableViewParcel.horizontalHeader().setStretchLastSection(True)
        self.tabParcel.layout().addWidget(self.tableViewParcel)

        self.setWindowTitle("XML-файл обміну кадастровою інформацією")
        # Створюємо об'єкт даних xml, який відображається у доквіджеті
        self.current_xml = self.xml_data(path="", tree=None, group_name=None)

        self.setup_custom_tab_buttons() # <- перенесемо сюди, після ініціалізації віджетів
        connector.connect(self.tabWidget, "tabCloseRequested", self.close_tab) # <- тут буде правильніше


    class xml_data:
        def __init__(self, path: str = "", tree: object = None, group_name: str = ""):  # Змінено
            self.path = path
            self.tree = tree
            self.group_name = group_name  # Зберігаємо тільки ім'я групи
            self.changed = False

        def __deepcopy__(self, memo):
            """
            Deep copy implementation for xml_data objects.
            """
            cls = self.__class__
            result = cls.__new__(cls)
            memo[id(self)] = result
            for k, v in self.__dict__.items():
                if k == "tree":
                    setattr(result, k, copy.deepcopy(v, memo))
                else:
                    setattr(result, k, copy.deepcopy(v, memo))
            return result

    def tab_button_clicked(self, index):
        """
        This method will be called when a tab's close button is clicked.
        """
        self.tabWidget.tabCloseRequested.emit(index)

    def setup_custom_tab_buttons(self):
        """
        Налаштовує кастомні кнопки закриття вкладок.
        """
        opt = QStyleOption()
        opt.initFrom(self)
        close_icon = self.style().standardIcon(QStyle.SP_TitleBarCloseButton, opt)

        # log_calls(logFile, "Налаштуваня кастомних кнопок закриття вкладок")


        tab_bar = self.tabWidget.tabBar()  # Move tab_bar here
        for i in range(self.tabWidget.count()):

            tab_name = self.tabWidget.tabText(i)
            # Не додаємо кнопку закриття для вкладок "Структура", "Метадані" і "Ділянка"
            if tab_name not in ["Структура", "Метадані", "Ділянка"]:
                tab_button = QPushButton(close_icon, "")
                tab_button.setObjectName(f"tab_close_button_{i}")
                # Встановлюємо розмір кнопки відповідно до розміру іконки
                tab_button.setFixedSize(close_icon.actualSize(
                    close_icon.availableSizes()[0]))
                tab_button.setStyleSheet("""
                    QPushButton {
                        border: none;
                        background-color: transparent;
                        padding: 0px;
                    }
                    QPushButton:hover {
                        background-color: lightgray;
                    }
                    QPushButton:pressed {
                        background-color: gray;
                    }
                """)
                tab_bar.setTabButton(i, QTabBar.RightSide, tab_button)
                #log_msg(logFile, f"Встановлюємо кнопку закриття для вкладки {i}")
                # Видаляємо попередні з'єднання, якщо такі є
                try:
                    connector.disconnect(tab_button, "clicked", self.tab_button_clicked)
                except TypeError:
                    pass  # Ігноруємо помилку, якщо з'єднань не було
                # Створюємо нове з'єднання
                connector.connect(tab_button, "clicked", lambda _, idx=i: self.tab_button_clicked(idx))

            else:
                # remove margin for static tabs
                tab_bar.setTabButton(i, QTabBar.RightSide, None)
                tab_bar.setTabButton(i, QTabBar.LeftSide, None)

        # log_msg(logFile, "Ініціалізація вкладок завершена\n---")


        self.tabWidget.setStyleSheet("""
            QTabWidget::tab-bar {
                alignment: left;
            }
            QTabBar::close-button {
                image: none; /* Приховуємо стандартні кнопки */
                subcontrol-position: right;
            }
            QTabBar::tab {
                padding: 5px;
            }
            QTabBar::tab:selected {
                /*margin-right: 0px;*/ /* Remove for all selected */
            }
            QTabBar::tab:!selected {
                /*margin-right: 0px; */ /* Remove for all not selected */
            }
             QTabBar::tab:!selected {
                margin-right: 0px; /* remove margin for all unselected */
            }
            QTabBar::tab:selected {
                margin-right: 0px; /* remove margin for all selected */
            }

            /* Special rules for static tabs (no close button) */
            QTabBar::tab:nth-child(1), /* Структура */
            QTabBar::tab:nth-child(2), /* Метадані */
            QTabBar::tab:nth-child(3) { /* Ділянка */
                margin-right: 0px; /* No margin for static tabs */
            }
        """)
        return



    def add_tab(self, tab_name, widget):
        """
        Додає вкладку з певним ім'ям і віджетом.

        References:
            update_restore_tabs_action
            restore_tabs
        Args:
            tab_name (str): Ім'я вкладки.
            widget (QWidget,self.tabXML,self.tabMetadata,
                self.tabParcel) 
                Віджет, який буде розміщений 
                на вкладці.
        """
        log_msg(logFile, tab_name)
        # Перевіряємо, чи вкладка вже існує
        for i in range(self.tabWidget.count()):
            if self.tabWidget.tabText(i) == tab_name:
                return  # Вкладка вже існує, виходимо з функції

        if tab_name == "Структура":
            layout = QVBoxLayout()
            layout.addWidget(self.treeViewXML)
            self.tabXML.setLayout(layout)
        elif tab_name == "Метадані":
            layout = QVBoxLayout()
            layout.addWidget(self.tableViewMetadata)
            self.tabMetadata.setLayout(layout)
        elif tab_name == "Ділянка":
            layout = QVBoxLayout()
            layout.addWidget(self.tableViewParcel)
            self.tabParcel.setLayout(layout)

        self.setup_custom_tab_buttons()

        self.tabWidget.addTab(widget, tab_name)

        # Add tab name to opened_tabs only if it's not already there
        if tab_name not in self.opened_tabs:
            self.opened_tabs.append(tab_name)
        if tab_name in self.closed_tabs:
            self.closed_tabs.remove(tab_name)
        self.plugin.update_restore_tabs_action()



    def load_data(self, xml_path, tree = None):

        # При виклику з process_group_click tree != None
        # При виклику з process_action_open tree == None

        # log_calls(logFile, f"xml_path = {xml_path}\ntree = {tree}")

        # заповнює дерево вкладки "Структура"
        self.treeViewXML.load_xml_to_tree_view(xml_path, xsd_path, tree)

        # 2) tree
        # self.current_xml.tree = self.treeViewXML.xml_tree # видалено
        self.current_xml.tree = self.treeViewXML.xml_tree  # Додано

        # заповнює вкладку "Метадані"
        # self.tableViewMetadata.fill_meta_data(self.treeViewXML.xml_tree)
        self.tableViewMetadata.fill_meta_data(self.current_xml.tree)
        # заповнює вкладку "Ділянка" та інші вкладки за необхідності
        # self.tableViewParcel.fill_parcel_data(self.treeViewXML.xml_tree)
        self.tableViewParcel.fill_parcel_data(self.current_xml.tree)

        self.treeViewXML.model.setHorizontalHeaderLabels(
            ["Елемент", "Значення"])
        self.tableViewMetadata.model().setHorizontalHeaderLabels([
            "Елемент", "Значення"])
        self.tableViewParcel.model().setHorizontalHeaderLabels([
            "Елемент", "Значення"])

        return

    def process_action_check(self):
        """ """
        log_msg(logFile, "Обробка події перевірки файлу XML")

        # level= Qgis.Success, Qgis.MessageLevel, Qgis.Info, Qgis.Warning, Qgis.Critical
        # duration sec 0 - до закриття
        self.parent.iface.messageBar().pushMessage(
            "xml_ua:", "Обробка події перевірки файлу XML", level=Qgis.Success, duration=0)
        QMessageBox.warning(self, "xml_ua:", "Вихід")
        self.handle_error_and_close("Обробка події перевірки файлу XML")

    def process_action_open(self):
        """
        Handles the action of opening an XML file.
        This method performs the following steps:
        1. Logs the action.
        2. Closes all tabs except "Структура", "Метадані", and "Ділянка".
        3. Clears existing data in TreeView and TableViews.
        4. Opens a file dialog to select an XML file.
        5. If no file is selected, shows a warning message and exits.
        6. Sets the window title to the selected file's name.
        7. Loads data from the selected XML file.
        8. Expands initial elements in the TreeView and sets the column width.
        9. Retrieves the layers_obj name from the XML layers and logs it.
        Returns:
            None
        """

        # log_calls(logFile)

        # Підготочий етап - закриваємо всі вкладки, крім "Структура", "Метадані" і "Ділянка"
        # створюємо нові віджети на вкладках
        # очищаємо моделі віджетів на вкладках, а не видаляємо їх

        # Видаляємо всі вкладки, крім "Структура", "Метадані" і "Ділянка"
        for i in reversed(range(self.tabWidget.count())):
            # цикл для кожної вкладки у зворотньому порядку
            tab_name = self.tabWidget.tabText(i)
            widget = self.tabWidget.widget(i)

            # видаляємо всі вкладки, крім "Структура", "Метадані" і "Ділянка"
            if tab_name not in ("Структура", "Метадані", "Ділянка"):
                self.tabWidget.removeTab(i)

            # якщо вкладка у списку tab_name
            else:
                # якщо вкладка зі списку tab_name має віджет,
                # то очищаємо його
                if widget:
                    # Очищаємо віджети на вкладках, а не видаляємо їх
                    layout = widget.layout()
                    if layout:
                        for j in reversed(range(layout.count())):
                            # видаляємо всі віджети з layout
                            layout_item = layout.itemAt(j)
                            # якщо в layout_item є віджет, то видаляємо його
                            if layout_item.widget():
                                layout_item.widget().deleteLater()
                            layout.removeItem(layout_item)

        # вкладка "Структура" у цьому місці коду завжди існує
        # перевірка на існування вкладки "Структура" зайвий крок
        # QMessageBox.information(self, "xml_ua:", "tab Структура вже існує")

        # створюємо нові віджети CustomTreeView, TableViewMetadata, TableViewParcel
        # (кожного разу при відкритті нового файлу)

        # отримуємо вказівник на layuot (полотно) вкладки "Структура"
        layout = self.tabXML.layout()
        # створюємо новий віджет CustomTreeView дерева xml
        self.treeViewXML = CustomTreeView(parent=self)
        self.treeViewXML.setObjectName("treeViewXML")
        # додаємо віджет CustomTreeView на полотно вкладки "Структура"
        layout.addWidget(self.treeViewXML)

        # отримуємо вказівник на layuot (полотно) вкладки "Метадані"
        layout = self.tabMetadata.layout()
        # створюємо новий віджет TableViewMetadata для відображення метаданих
        self.tableViewMetadata = TableViewMetadata(parent=self)
        self.tableViewMetadata.setObjectName("tableViewMetadata")
        self.tableViewMetadata.horizontalHeader().setStretchLastSection(True)
        # додаємо віджет TableViewMetadata на полотно вкладки "Метадані"
        layout.addWidget(self.tableViewMetadata)

        # отримуємо вказівник на layuot (полотно) вкладки "Ділянка"
        layout = self.tabParcel.layout()
        # створюємо новий віджет TableViewParcel для відображення ділянок
        self.tableViewParcel = TableViewParcel(parent=self)
        self.tableViewParcel.setObjectName("tableViewParcel")
        self.tableViewParcel.horizontalHeader().setStretchLastSection(True)
        # додаємо віджет TableViewParcel на полотно вкладки "Ділянка"
        layout.addWidget(self.tableViewParcel)

        # Очищаємо дерево, таблицю метаданих та таблицю ділянок
        self.treeViewXML.model.clear()
        self.tableViewMetadata.model().clear()
        self.tableViewParcel.model().clear()

        # Основний етап - відкриваємо файл XML

        xml_path, _ = QFileDialog.getOpenFileName(
            self, "Відкрити XML файл", "", "XML файли (*.xml)")

        if not xml_path:
            QMessageBox.warning(self, "Помилка", "Файл не вибрано.")
            return

        # Теоретично:
        # Тут потрібно перевірити чи файл відповідає схемі XSD
        # Практично:
        # файл завжди не відповідає схемі XSD,
        # хоча, ніби, він створюється саме згідно з нею
        # Тому треба перевірити файл на відповідність структурі xml
        # це: наявність кореневого елемента, обов'язкових елементів
        # відповіденість відкритих тегів закритим, відповідність атрибутів
        # тут поки неповна шивка перевірка
        if not self.validate_xml_structure(xml_path):
            log_msg(logFile, "Неправильна структура файлу XML.")
            QMessageBox.warning(
                self, "Помилка", "Неправильна структура файлу XML.")
            return
        else:
            # log_msg(logFile, "Файл відповідає структурі XML.")
            # QMessageBox.information(self, "Успіх", "Файл відповідає структурі XML.")
            pass

        # встановлюємо атрибут - повне ім'я файлу xml
        self.full_xml_file_name = xml_path

        # current xml має 3 атрибути: full_path, tree, group
        # 1) full_path
        self.current_xml.path = xml_path
        # оновлюємо заголовок віджета
        self.update_window_title(self.current_xml.path)

        # завантажуємо дані з файлу xml
        # заповнюємо дерево, таблицю метаданих та таблицю ділянок
        # load data
        self.load_data(self.full_xml_file_name, tree = None)
        # 2) tree
        self.current_xml.tree = self.treeViewXML.xml_tree

        # конфігуруємо зовнішній вигляд дерева
        self.treeViewXML.expand_initial_elements()
        self.treeViewXML.set_column_width(0, 75)
        self.setup_custom_tab_buttons()

        # ініціалізуємо заповнення шарів
        self.layers_obj = xmlUaLayers(xml_path, self.current_xml.tree, plugin=self.plugin) # Pass self.plugin
        # log_msg(logFile, f"{self.layers_obj}")
        # 3) group
        self.current_xml.group_name = self.layers_obj.group.name()
        # log_msg(logFile, f"{self.current_xml.group_name}")

        # current_xml зміниться у майбутньому при відкритті xml
        # або при навігації по групах, тому треба
        # до списку додати його клон

        clone_xml = copy.deepcopy(self.current_xml)
        self.opened_xmls.append(clone_xml)

        # цей виклик мабуть є зайвим бо
        # бо дублюється у xml_ua.py:on_open_tool
        self.plugin.connect_layer_signals()

        return


    def process_action_new(self, tree):
        """
        """
        # Процес створення нового xml
        # У цьому місці користувач вибравши пункт 
        # меню "Новий" вибрав папку і назву файлу 
        # шаблон зчитаний і розпарсений ???
        # треба зберегти дерево xml на диск і відкрити 
        # відкрити його без перевіоки наявності всіх
        # обов'язкових елементів схеми оскільки файл
        # у процесі розробки
        
        log_calls(logFile)

        # Підготочий етап - закриваємо всі вкладки, крім 
        # "Структура", "Метадані" і "Ділянка"
        # створюємо нові віджети на вкладках
        # очищаємо моделі віджетів на вкладках, а не видаляємо їх

        # Видаляємо всі вкладки, крім 
        # "Структура", "Метадані" і "Ділянка"
        for i in reversed(range(self.tabWidget.count())):
            # цикл для кожної вкладки у зворотньому порядку
            tab_name = self.tabWidget.tabText(i)
            widget = self.tabWidget.widget(i)

            # видаляємо всі вкладки, крім "Структура", "Метадані" і "Ділянка"
            if tab_name not in ("Структура", "Метадані", "Ділянка"):
                self.tabWidget.removeTab(i)

            # якщо вкладка у списку tab_name
            else:
                # якщо вкладка зі списку tab_name має віджет,
                # то очищаємо його
                if widget:
                    # Очищаємо віджети на вкладках, а не видаляємо їх
                    layout = widget.layout()
                    if layout:
                        for j in reversed(range(layout.count())):
                            # видаляємо всі віджети з layout
                            layout_item = layout.itemAt(j)
                            # якщо в layout_item є віджет, то видаляємо його
                            if layout_item.widget():
                                layout_item.widget().deleteLater()
                            layout.removeItem(layout_item)

        # вкладка "Структура" у цьому місці коду завжди існує
        # перевірка на існування вкладки "Структура" зайвий крок
        # QMessageBox.information(self, "xml_ua:", "tab Структура вже існує")

        # створюємо нові віджети CustomTreeView, TableViewMetadata, TableViewParcel
        # (кожного разу при створенні нового файлу)

        # отримуємо вказівник на layuot (полотно) вкладки "Структура"
        layout = self.tabXML.layout()
        # створюємо новий віджет CustomTreeView дерева xml
        self.treeViewXML = CustomTreeView(parent=self)
        self.treeViewXML.setObjectName("treeViewXML")
        # додаємо віджет CustomTreeView на полотно вкладки "Структура"
        layout.addWidget(self.treeViewXML)

        # отримуємо вказівник на layuot (полотно) вкладки "Метадані"
        layout = self.tabMetadata.layout()
        # створюємо новий віджет TableViewMetadata для відображення метаданих
        self.tableViewMetadata = TableViewMetadata(parent=self)
        self.tableViewMetadata.setObjectName("tableViewMetadata")
        self.tableViewMetadata.horizontalHeader().setStretchLastSection(True)
        # додаємо віджет TableViewMetadata на полотно вкладки "Метадані"
        layout.addWidget(self.tableViewMetadata)

        # отримуємо вказівник на layuot (полотно) вкладки "Ділянка"
        layout = self.tabParcel.layout()
        # створюємо новий віджет TableViewParcel для відображення ділянок
        self.tableViewParcel = TableViewParcel(parent=self)
        self.tableViewParcel.setObjectName("tableViewParcel")
        self.tableViewParcel.horizontalHeader().setStretchLastSection(True)
        # додаємо віджет TableViewParcel на полотно вкладки "Ділянка"
        layout.addWidget(self.tableViewParcel)

        # Очищаємо дерево, таблицю метаданих та таблицю ділянок
        self.treeViewXML.model.clear()
        self.tableViewMetadata.model().clear()
        self.tableViewParcel.model().clear()

        # Основний етап - відкриваємо файл XML

        # xml_path, _ = QFileDialog.getOpenFileName(
        #     self, "Відкрити XML файл", "", "XML файли (*.xml)")

        # if not xml_path:
        #     QMessageBox.warning(self, "Помилка", "Файл не вибрано.")
        #     return

        # Теоретично:
        # Тут потрібно перевірити чи файл відповідає схемі XSD
        # Практично:
        # файл завжди не відповідає схемі XSD,
        # хоча, ніби, він створюється саме згідно з нею
        # Тому треба перевірити файл на відповідність структурі xml
        # це: наявність кореневого елемента, обов'язкових елементів
        # відповіденість відкритих тегів закритим, відповідність атрибутів
        # тут поки неповна шивка перевірка
        # if not self.validate_xml_structure(xml_path):
        #     log_msg(logFile, "Неправильна структура файлу XML.")
        #     QMessageBox.warning(
        #         self, "Помилка", "Неправильна структура файлу XML.")
        #     return
        # else:
        #     # log_msg(logFile, "Файл відповідає структурі XML.")
        #     # QMessageBox.information(self, "Успіх", "Файл відповідає структурі XML.")
        #     pass

        # # встановлюємо атрибут - повне ім'я файлу xml
        # self.full_xml_file_name = xml_path

        # current xml має 3 атрибути: full_path, tree, group
        # 1) full_path

        self.current_xml.path = xml_path
        # оновлюємо заголовок віджета
        self.update_window_title(self.current_xml.path)

        # завантажуємо дані з файлу xml
        # заповнюємо дерево, таблицю метаданих та таблицю ділянок
        # load data
        self.load_data(self.full_xml_file_name, tree = None)
        # 2) tree
        self.current_xml.tree = self.treeViewXML.xml_tree

        # конфігуруємо зовнішній вигляд дерева
        self.treeViewXML.expand_initial_elements()
        self.treeViewXML.set_column_width(0, 75)
        self.setup_custom_tab_buttons()

        # ініціалізуємо заповнення шарів
        #✔️ 2025.03.27 15:31 наступний рядок зайвий
        # бо нижче те саме з іншими параметрами
        # self.layers_obj = xmlUaLayers(xml_path, self.current_xml.tree)
        # log_msg(logFile, f"{self.layers_obj}")
        # 3) group
        self.layers_obj = xmlUaLayers(xml_path, self.current_xml.tree, plugin=self.plugin) # Pass self.plugin
        # log_msg(logFile, f"{self.current_xml.group_name}")

        # current_xml зміниться у майбутньому при відкритті xml
        # або при навігації по групах, тому треба
        # до списку додати його клон

        clone_xml = copy.deepcopy(self.current_xml)
        self.opened_xmls.append(clone_xml)

        return


    def resizeEvent(self, event):
        """
        Оновлює заголовок віджета при зміні розміру віджета.
        """
        super().resizeEvent(event)
        self.update_window_title(self.current_xml.path)

    def update_window_title(self, file_name):
        """
        Оновлює заголовок віджета, враховуючи доступну ширину та 
        обрізаючи назву файлу, якщо потрібно.
        """
        # log_calls(logFile, f"file_name = '{file_name}'")

        # Check if the full_xml_file_name is set
        if not file_name:
            self.setWindowTitle("XML-файл обміну кадастровою інформацією")
            return

        # Calculate available width for the title, subtracting 30 pixels for the menu buttons
        # title_width = self.width() - self.style().pixelMetric(QStyle.PM_DockWidgetTitleBarButtonMargin) * 2 - 60
        title_width = self.width() - 80
        # title_width = 150

        # Get the font metrics
        font_metrics = self.fontMetrics()

        # Elide (truncate) the path from the left (show the end)
        elided_text = font_metrics.elidedText(
            file_name, Qt.ElideLeft, title_width)

        # Set the elided text as the window title
        self.setWindowTitle(elided_text)

    def process_action_save(self):

        # Зберігаємо дерево xml, на диск зі стандартним іменем
        # зчитаним з диску, або ???
        #✔️ 2025.03.21 14:45
        # поки при збереженні вибирається папка 
        # це питання ❓🔨 чи дозволяти вибирати папку
        #         

        log_msg(logFile)

        frame = inspect.currentframe()

        # folder_path = QFileDialog.getExistingDirectory(
        #     None, "Виберіть папку для збереження")

        # if folder_path:
        #     full_path = f"{folder_path}/{self.full_xml_file_name}"

        #     self.treeViewXML.save_xml_tree(self.treeViewXML.xml_tree, full_path)
        if self.full_xml_file_name:
            self.treeViewXML.save_xml_tree(self.treeViewXML.xml_tree, self.full_xml_file_name)
            QMessageBox.information(None, "Успіх", f"Файл збережено: {self.full_xml_file_name}")
            return
        else:
            QMessageBox.warning(None, "Помилка", "Файл не відкритий.")
            
            return


    def process_action_save_as(self):

        # призначена для збереження XML можливо в іншу папку 
        # і під іншим іменем

        log_msg(logFile)

        # folder_path = QFileDialog.getExistingDirectory(
        #     self, "Виберіть папку для збереження")
        # if not folder_path:
        #     QMessageBox.warning(self, "Помилка", "Папку не вибрано.")
        #     return

        # save_path = os.path.join(folder_path, "збережений_файл.xml")


        # Запитуємо у користувача шлях для збереження нового XML файлу
        save_path, _ = QFileDialog.getSaveFileName(None, "Зберегти XML файл", "", "XML файли (*.xml)")
        if not save_path:
            log_calls(logFile, "Шлях для збереження не вибрано.")
            return None

        self.treeViewXML.save_xml_tree(self.treeViewXML.xml_tree, save_path)
        QMessageBox.information(self, "Успіх", f"Файл збережено: {save_path}")


    def get_tooltip_from_tree(self, full_path, default_name):
        """
        Отримує tooltip для елемента з дерева за його шляхом.
        Якщо tooltip не знайдено, повертає default_name.
        """
        # log_msg(logFile)  # recursion
        tree_index = self.find_element_index(
            path=full_path)  # Пошук елемента за шляхом
        if tree_index.isValid():
            tree_item = self.treeViewXML.model.itemFromIndex(tree_index)
            if tree_item:
                return tree_item.toolTip() or default_name  # Повертає tooltip або default_name

        return default_name

    def find_element_index(self, path=None, element_name=None):
        """
        Знаходить індекс елемента у дереві на основі шляху або імені.
        """
        # log_msg(logFile) # recursion
        if path:
            # Логіка пошуку за шляхом
            current_index = QModelIndex()
            path_parts = path.split("/")  # Розділяємо шлях на частини
            for part in path_parts:
                found = False
                for row in range(self.treeViewXML.model.rowCount(current_index)):
                    child_index = self.treeViewXML.model.index(
                        row, 0, current_index)
                    child_item = self.treeViewXML.model.itemFromIndex(
                        child_index)
                    if child_item and child_item.text() == part:
                        # Переходимо на наступний рівень дерева
                        current_index = child_index
                        found = True
                        break
                if not found:
                    # Якщо будь-яка частина шляху не знайдена, повертаємо пустий індекс
                    return QModelIndex()
            return current_index
        elif element_name:
            # Логіка пошуку за іменем
            for row in range(self.treeViewXML.model.rowCount()):
                # Припустимо, імена у першій колонці
                item = self.treeViewXML.model.item(row, 0)
                if item and item.text() == element_name:
                    return self.treeViewXML.model.indexFromItem(item)
        return QModelIndex()

    def handle_error_and_close(self, error_message):
        """
            Обробляє помилку, відображає повідомлення і закриває док-віджет.

            Аргументи:
                Текст повідомлення про помилку.
        """
        log_msg(logFile)

        self.parent.iface.messageBar().pushCritical("Помилка", error_message)
        self.close()

    def removeTab(self, index):
        tab_name = self.tabWidget.tabText(index)
        self.tabWidget.removeTab(index)
        if tab_name in self.opened_tabs:
            self.opened_tabs.remove(tab_name)
        self.update_restore_tabs_action()

    def showEvent(self, event):
        """ 
            Відновлення вкладок при відкритті вікна 

        """
        # Обробка події показу віджета.
        # Подія виникає, перед тим як віджет стає видимим.

        # log_calls(logFile, f"event = {event}")

        super().showEvent(event)
        if self.plugin and not self.isVisible():
            self.restore_tabs()
        # self.isVisible = True # we need to set the flag after calling self.restore_tabs()

    def close_tab(self, index):
        """
        Handle tab close events.
        """
        tab_name = self.tabWidget.tabText(index)

        log_msg(logFile, tab_name)
        if tab_name in ["Структура", "Метадані", "Ділянка"]:
            return

        if tab_name not in ["Структура", "Метадані", "Ділянка"]:
            self.closed_tabs.append(tab_name)
        self.removeTab(index)
        self.update_restore_tabs_action()
        self.update_tab_indices()

    def update_restore_tabs_action(self):
        """
        Оновлює стан дії "Відновити закриті вкладки".
        """
        if self.plugin:
            closed_tabs_exist = len(self.closed_tabs) > 0
            self.plugin.action_restore_tabs.setEnabled(closed_tabs_exist)

    def restore_tabs(self):
        """
        Відновлює вкладки, що були відкриті в попередній сесії.
        """
        log_calls(logFile)

        # Відновлюємо відкриті вкладки, якщо вони були збережені
        for tab_name in self.opened_tabs:
            if tab_name == "Структура":
                self.add_tab("Структура", self.tabXML)
            elif tab_name == "Метадані":
                self.add_tab("Метадані", self.tabMetadata)
            elif tab_name == "Ділянка":
                self.add_tab("Ділянка", self.tabParcel)

        # Відновлюємо вкладки зі списку закритих, якщо вони були закриті в поточній сесії
        for tab_name in self.closed_tabs:
            if tab_name not in self.opened_tabs:
                if tab_name not in ["Структура", "Метадані", "Ділянка"]:
                    self.opened_tabs.append(tab_name)

        self.setup_custom_tab_buttons()
        if self.plugin and hasattr(self.plugin, 'update_restore_tabs_action'):
            self.plugin.update_restore_tabs_action()

    def update_restore_tabs_action(self):
        """
        Оновлює стан дії "Відновити закриті вкладки".
        """
        if self.plugin:
            closed_tabs_exist = len(self.closed_tabs) > 0
            self.plugin.action_restore_tabs.setEnabled(closed_tabs_exist)

    def removeTab(self, index):
        tab_name = self.tabWidget.tabText(index)
        self.tabWidget.removeTab(index)
        if tab_name in self.opened_tabs:
            self.opened_tabs.remove(tab_name)
        self.update_restore_tabs_action()

    def restore_tabs(self):
        """
        Відновлює вкладки, що були відкриті в попередній сесії.
        """
        log_calls(logFile, f"closed_tabs: {self.closed_tabs}")

        # Відновлюємо вкладки зі списку закритих
        for tab_name in self.closed_tabs:
            if tab_name not in self.opened_tabs:
                if tab_name == "Структура":
                    self.add_tab("Структура", self.tabXML)
                    self.load_data(self.full_xml_file_name)
                elif tab_name == "Метадані":
                    self.add_tab("Метадані", self.tabMetadata)
                    self.load_data(self.full_xml_file_name)
                elif tab_name == "Ділянка":
                    self.add_tab("Ділянка", self.tabParcel)
                    self.load_data(self.full_xml_file_name)
                else:
                    # Відновлюємо інші вкладки
                    self.add_tab(tab_name, QWidget())

        self.closed_tabs.clear()
        self.setup_custom_tab_buttons()
        if self.plugin and hasattr(self.plugin, 'update_restore_tabs_action'):
            self.plugin.update_restore_tabs_action()


    def update_tab_indices(self):
        """
        Оновлює індекси вкладок після закриття.
        """

        log_calls(logFile)

        for i in range(self.tabWidget.count()):
            tab_bar = self.tabWidget.tabBar()
            tab_button = tab_bar.tabButton(i, QTabBar.RightSide)
            if tab_button:
                # Disconnect old connections
                try:
                    connector.disconnect(tab_button, "clicked", self.tab_button_clicked)
                except TypeError:
                    pass

                # Set new object name and connect the button
                tab_button.setObjectName(f"tab_close_button_{i}")
                # Use lambda to pass the index correctly
                connector.connect(tab_button, "clicked", lambda _, idx=i: self.tab_button_clicked(idx))


    def generate_layers_obj_name(self, base_name):
        """
        Формує назву групи на основі базової назви, додаючи суфікс, якщо група з такою назвою вже існує.

        Args:
            base_name (str): Базова назва групи (назва файлу без розширення).

        Returns:
            str: Назва групи.
        """
        layers_obj_name = base_name
        suffix = 0

        while self.layers_root.findGroup(layers_obj_name):
            suffix += 1
            layers_obj_name = f"{base_name}#{suffix}"

        return layers_obj_name

    def double_clicked(self, index):
        """
        Обробляє подвійне клацання на елементі в дереві шарів.
        """
        log_calls(logFile, f"index = {index}")

        # Отримуємо QgsLayerTreeNode, використовуючи QgsLayerTreeView
        item = self.iface.layerTreeView().index2node(index)

        if item is None:
            log_msg(logFile, f"item is None")
            return

        # log_msg(logFile, f"item.name() = {item.name()}")

        if isinstance(item, QgsLayerTreeGroup):
            layers_obj_name = item.name()
            log_msg(
                logFile, f"layers_obj_name = {layers_obj_name}")

    def clicked(self, index):
        """
        Обробляє  клацання на елементі в дереві шарів.
        """
        # log_calls(logFile, f"index = {index}")

        # Отримуємо QgsLayerTreeNode, використовуючи QgsLayerTreeView
        item = self.iface.layerTreeView().index2node(index)

        if item is None:
            log_msg(logFile, f"item is None")
            return

        if isinstance(item, QgsLayerTreeGroup):
            self.process_group_click(item.name())

    def validate_xml_structure(self, xml_path):

        #✔️ 2025.04.03 08:59
        # Перевіряти треба xml при відкритті і шаблони при створенні, бо
        # користувач може зробити помилку у шаблоні 
        # Це часткова перевірка структури XML
        # Повна перевірка структури XML засобами library lxml
        # не працює, бо ВСІ файли не відповідають схемі XSD
        # у майбутньому треба розширити перевірку
        # з врахуванням того, що файл може бути у процесі розробки

        #✔️ 2025.04.03  
        # log_msg(logFile)

        # Список обов'язкових елементів
        mandatory_elements = [
            "AdditionalPart",
            "ServiceInfo",
            "FileID",
            "FormatVersion",
            "FileDate",
            "FileGUID",
            "ReceiverName",
            "ReceiverIdentifier",
            "Software",
            "SoftwareVersion",
            "InfoLandWork",
            "Executor",
            "CompanyName",
            "Chief",
            "Address",
            "InfoPart",
            "MetricInfo",
            "CoordinateSystem",
            "HeightSystem",
            "MeasurementUnit",
            "PointInfo",
            "Polyline",
            "ControlPoint",
            "CadastralZoneInfo",
            "CadastralZoneNumber",
            "CadastralQuarterInfo",
            "CadastralQuarterNumber",
            "ParcelInfo",
            "ParcelMetricInfo"
        ]
        try:
            # 1. Parse the XML (Well-Formedness Check)
            tree = etree.parse(xml_path)
            root = tree.getroot()

            # 2. Check for a Root Element
            if root is None:
                log_msg(logFile, "Error: No root element found in the XML file.")
                return False

            # Check if the root element's tag is 'UkrainianCadastralExchangeFile'
            if root.tag != "UkrainianCadastralExchangeFile":
                log_msg(
                    logFile, f"Error: Root element is '{root.tag}', expected 'UkrainianCadastralExchangeFile'.")
                return False

            for element_name in mandatory_elements:
                element = root.find(".//" + element_name)
                if element is None:
                    log_msg(
                        logFile, f"Error: Mandatory element '{element_name}' is missing.")
                    return False
        except Exception as e:
            log_msg(logFile, f"Error during XML structure validation: {e}")
            return False

        return True


    def process_group_click(self, group_name):


        # Основна мета — синхронізувати доквіджет з вибраною групою 
        # в дереві шарів QGIS коли користувач клацає групу, 

        log_calls(logFile, group_name)

        if not hasattr(self, 'opened_xmls'):
            QMessageBox.warning(self, "process_group_click()",
                                "not hasattr(self, 'opened_xmls')")
            log_msg(logFile, "Error: opened_xmls attribute is not initialized.")
            return

        layers_root = QgsProject.instance().layerTreeRoot()
        clicked_group = layers_root.findGroup(group_name)
        #log_msg(logFile, f"clicked_group = {clicked_group}")
        if not clicked_group:
            log_msg(
                logFile, f"Group '{group_name}' not found in the layer tree")
            return

        # шукаємо елемент списку відкритих xml,
        found = False
        for xml in self.opened_xmls:
            if xml.group_name == group_name:
                self.current_xml = xml
                found = True
                log_msg(logFile, f"Group '{group_name}' found in opened_xmls")
                # QMessageBox.information(self, "process_group_click()","group " + group_name + " found")
                break

        if not found:
            log_msg(logFile, f"Нема відкритого xml з іменем '{group_name}'")
            return

        if self.isHidden():
            self.show()

        # ✔️ 2025.03.08 10:01 очистка_вікна
        self.plugin.clear_widget_data()

        self.load_data(self.current_xml.path, self.current_xml.tree)
        self.treeViewXML.expand_initial_elements()
        self.treeViewXML.set_column_width(0, 75)

        # конфігуруємо зовнішній вигляд дерева
        self.treeViewXML.expand_initial_elements()
        self.treeViewXML.set_column_width(0, 75)
        self.setup_custom_tab_buttons()

        # відновлюємо заголовок доквіджета
        self.update_window_title(self.current_xml.path)


    # def on_layer_geometry_changed(self, layer_id, feature_id, geometry):

    #     """
    #     Обробник події зміни геометрії фічі шару.
    #     """

    #     log_calls(logFile, f"layer_id: {layer_id}, feature_id: {feature_id}, geometry: {geometry}")

    #     # Отримуємо шар за його ID
    #     # instance() -> поточний екземпляр проєкту QGIS
    #     layer = QgsProject.instance().mapLayer(layer_id) 
    #     if not layer:
    #         log_msg(logFile, f"Шар з ID {layer_id} не знайдено.")
    #         return

    #     # Отримуємо фічу за її ID
    #     feature = layer.getFeature(feature_id)
    #     if not feature:
    #         log_msg(logFile, f"Фіча з ID {feature_id} не знайдена в шарі {layer.name()}.")
    #         return

    #     # Отримуємо геометрію фічі
    #     new_geometry = feature.geometry()
    #     log_msg(logFile, f"Нова геометрія фічі: {geometry_to_string(new_geometry)}")

    #     # Тут потрібно додати логіку для оновлення XML-файлу
    #     # на основі нової геометрії
    #     if self.dockwidget:
    #         self.dockwidget.update_xml_with_new_geometry(layer, feature, new_geometry)

    def update_xml_with_new_geometry(self, layer, feature_id, geometry):
        """
        Оновлює XML-файл на основі нової геометрії.
        """
        # log_calls(logFile, f"layer: {layer.name()}, feature_id: {feature_id}, geometry: {geometry}")
        log_calls(logFile)

        # Отримуємо фічу за її ID
        feature = layer.getFeature(feature_id)
        if not feature:
            log_msg(logFile, f"Фіча з ID {feature_id} не знайдена в шарі {layer.name()}.")
            return

        # Отримуємо геометрію фічі
        new_geometry = feature.geometry()
        log_calls(logFile, f"Нова геометрія фічі: {geometry_to_string(new_geometry)}")

        # TODO: Тут потрібно додати логіку для оновлення 
        # XML-файлу на основі нової геометрії
        QMessageBox.information(self, "update_xml_with_new_geometry()", f"Нова геометрія фічі: {geometry_to_string(new_geometry)}")
        
