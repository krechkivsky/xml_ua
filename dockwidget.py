
"""
/***************************************************************************
 xml_uaDockWidget
                                 A QGIS plugin
 Processing ukrainian cadastral files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-01
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Mike
        email                : michael.krechkivski@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import inspect
import copy

from lxml import etree

from qgis.PyQt import uic

from qgis.PyQt.QtGui import QIcon

from qgis.PyQt.QtCore import QModelIndex
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtCore import Qt

from qgis.core import Qgis
from qgis.core import QgsLayerTreeGroup
from qgis.core import QgsProject

from qgis.PyQt.QtWidgets import QDockWidget
from qgis.PyQt.QtWidgets import QWidget
from qgis.PyQt.QtWidgets import QVBoxLayout
from qgis.PyQt.QtWidgets import QHBoxLayout
from qgis.PyQt.QtWidgets import QMenu
from qgis.PyQt.QtWidgets import QAction
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.PyQt.QtWidgets import QToolButton
from qgis.PyQt.QtWidgets import QStyle
from qgis.PyQt.QtWidgets import QTreeView
from qgis.PyQt.QtWidgets import QFileDialog
from qgis.PyQt.QtWidgets import QTableView

from qgis.PyQt.QtWidgets import QTabWidget, QStyleOption, QWidget, QStyle, QPushButton, QTabBar
from qgis.PyQt.QtGui import QPainter, QIcon, QPalette
from qgis.PyQt.QtCore import QSettings

from .tree_view import CustomTreeView
from .metadata import TableViewMetadata
from .parcel import TableViewParcel
from .layers import xmlUaLayers

from .common import logFile
from .common import log_msg
from .common import log_calls
from .common import xsd_path
from .common import connector
from .common import geometry_to_string


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'xml_ua_dockwidget_base.ui'))


class xml_uaDockWidget(QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None, plugin=None):






        super().__init__(parent)

        self.iface = plugin.iface  # add iface to class

        connector.connect(self.iface.layerTreeView(), "doubleClicked", self.double_clicked)
        connector.connect(self.iface.layerTreeView(), "clicked", self.clicked)

        self.plugin = plugin

        self.setupUi(self)
        self.parent = parent


        self.opened_xmls = []


        self.full_xml_file_name = None

        self.closed_tabs = []

        self.layers_obj = None
        self.full_xml_file_name = ""
        self.tabWidget.setTabsClosable(True)



        self.layers_root = QgsProject.instance().layerTreeRoot()

        old_tree_view = self.findChild(QTreeView, "treeViewXML")
        self.treeViewXML = CustomTreeView(parent=self)
        if old_tree_view:
            layout = self.tabXML.layout()
            if layout:
                layout.removeWidget(old_tree_view)
            old_tree_view.setParent(None)
            old_tree_view.deleteLater()
        self.treeViewXML.setObjectName("treeViewXML")
        self.tabXML.layout().addWidget(self.treeViewXML)

        old_table_view = self.findChild(QTableView, "tableViewMetadata")
        if old_table_view:
            layout = self.tabMetadata.layout()
            if layout:
                layout.removeWidget(old_table_view)
            old_table_view.setParent(None)
            old_table_view.deleteLater()
        self.tableViewMetadata = TableViewMetadata(parent=self)  # ✅
        self.tableViewMetadata.setObjectName(
            "tableViewMetadata")  # Залишаємо те саме ім'я
        self.tableViewMetadata.horizontalHeader().setStretchLastSection(True)
        self.tabMetadata.layout().addWidget(self.tableViewMetadata)  # Додаємо до layout

        old_parcel_view = self.findChild(QTableView, "tableViewParcel")
        if old_parcel_view:
            layout = self.tabParcel.layout()
            if layout:
                layout.removeWidget(old_table_view)
                layout.removeWidget(old_parcel_view)
            old_parcel_view.setParent(None)
            old_parcel_view.deleteLater()
        self.tableViewParcel = TableViewParcel(parent=self)
        self.tableViewParcel.setObjectName("tableViewParcel")
        self.tableViewParcel.horizontalHeader().setStretchLastSection(True)
        self.tabParcel.layout().addWidget(self.tableViewParcel)

        self.setWindowTitle("XML-файл обміну кадастровою інформацією")

        self.current_xml = self.xml_data(path="", tree=None, group_name=None)

        self.setup_custom_tab_buttons() # <- перенесемо сюди, після ініціалізації віджетів
        connector.connect(self.tabWidget, "tabCloseRequested", self.close_tab) # <- тут буде правильніше


    class xml_data:
        def __init__(self, path: str = "", tree: object = None, group_name: str = ""):  # Змінено
            self.path = path
            self.tree = tree
            self.group_name = group_name  # Зберігаємо тільки ім'я групи
            self.changed = False

        def __deepcopy__(self, memo):
            """
            Deep copy implementation for xml_data objects.
            """
            cls = self.__class__
            result = cls.__new__(cls)
            memo[id(self)] = result
            for k, v in self.__dict__.items():
                if k == "tree":
                    setattr(result, k, copy.deepcopy(v, memo))
                else:
                    setattr(result, k, copy.deepcopy(v, memo))
            return result

    def tab_button_clicked(self, index):
        """
        This method will be called when a tab's close button is clicked.
        """
        self.tabWidget.tabCloseRequested.emit(index)

    def setup_custom_tab_buttons(self):
        """
        Налаштовує кастомні кнопки закриття вкладок.
        """
        opt = QStyleOption()
        opt.initFrom(self)
        close_icon = self.style().standardIcon(QStyle.SP_TitleBarCloseButton, opt)




        tab_bar = self.tabWidget.tabBar()  # Move tab_bar here
        for i in range(self.tabWidget.count()):

            tab_name = self.tabWidget.tabText(i)

            if tab_name not in ["Структура", "Метадані", "Ділянка"]:
                tab_button = QPushButton(close_icon, "")
                tab_button.setObjectName(f"tab_close_button_{i}")

                tab_button.setFixedSize(close_icon.actualSize(
                    close_icon.availableSizes()[0]))
                tab_button.setStyleSheet("""
                    QPushButton {
                        border: none;
                        background-color: transparent;
                        padding: 0px;
                    }
                    QPushButton:hover {
                        background-color: lightgray;
                    }
                    QPushButton:pressed {
                        background-color: gray;
                    }
                """)
                tab_bar.setTabButton(i, QTabBar.RightSide, tab_button)


                try:
                    connector.disconnect(tab_button, "clicked", self.tab_button_clicked)
                except TypeError:
                    pass  # Ігноруємо помилку, якщо з'єднань не було

                connector.connect(tab_button, "clicked", lambda _, idx=i: self.tab_button_clicked(idx))

            else:

                tab_bar.setTabButton(i, QTabBar.RightSide, None)
                tab_bar.setTabButton(i, QTabBar.LeftSide, None)




        self.tabWidget.setStyleSheet("""
            QTabWidget::tab-bar {
                alignment: left;
            }
            QTabBar::close-button {
                image: none; /* Приховуємо стандартні кнопки */
                subcontrol-position: right;
            }
            QTabBar::tab {
                padding: 5px;
            }
            QTabBar::tab:selected {
                /*margin-right: 0px;*/ /* Remove for all selected */
            }
            QTabBar::tab:!selected {
                /*margin-right: 0px; */ /* Remove for all not selected */
            }
             QTabBar::tab:!selected {
                margin-right: 0px; /* remove margin for all unselected */
            }
            QTabBar::tab:selected {
                margin-right: 0px; /* remove margin for all selected */
            }

            /* Special rules for static tabs (no close button) */
            QTabBar::tab:nth-child(1), /* Структура */
            QTabBar::tab:nth-child(2), /* Метадані */
            QTabBar::tab:nth-child(3) { /* Ділянка */
                margin-right: 0px; /* No margin for static tabs */
            }
        """)
        return



    def add_tab(self, tab_name, widget):
        """
        Додає вкладку з певним ім'ям і віджетом.

        References:
            update_restore_tabs_action
            restore_tabs
        Args:
            tab_name (str): Ім'я вкладки.
            widget (QWidget,self.tabXML,self.tabMetadata,
                self.tabParcel) 
                Віджет, який буде розміщений 
                на вкладці.
        """
        log_msg(logFile, tab_name)

        for i in range(self.tabWidget.count()):
            if self.tabWidget.tabText(i) == tab_name:
                return  # Вкладка вже існує, виходимо з функції

        if tab_name == "Структура":
            layout = QVBoxLayout()
            layout.addWidget(self.treeViewXML)
            self.tabXML.setLayout(layout)
        elif tab_name == "Метадані":
            layout = QVBoxLayout()
            layout.addWidget(self.tableViewMetadata)
            self.tabMetadata.setLayout(layout)
        elif tab_name == "Ділянка":
            layout = QVBoxLayout()
            layout.addWidget(self.tableViewParcel)
            self.tabParcel.setLayout(layout)

        self.setup_custom_tab_buttons()

        self.tabWidget.addTab(widget, tab_name)


        if tab_name not in self.opened_tabs:
            self.opened_tabs.append(tab_name)
        if tab_name in self.closed_tabs:
            self.closed_tabs.remove(tab_name)
        self.plugin.update_restore_tabs_action()



    def load_data(self, xml_path, tree = None):







        self.treeViewXML.load_xml_to_tree_view(xml_path, xsd_path, tree)



        self.current_xml.tree = self.treeViewXML.xml_tree  # Додано



        self.tableViewMetadata.fill_meta_data(self.current_xml.tree)


        self.tableViewParcel.fill_parcel_data(self.current_xml.tree)

        self.treeViewXML.model.setHorizontalHeaderLabels(
            ["Елемент", "Значення"])
        self.tableViewMetadata.model().setHorizontalHeaderLabels([
            "Елемент", "Значення"])
        self.tableViewParcel.model().setHorizontalHeaderLabels([
            "Елемент", "Значення"])

        return

    def process_action_check(self):
        """ """
        log_msg(logFile, "Обробка події перевірки файлу XML")



        self.parent.iface.messageBar().pushMessage(
            "xml_ua:", "Обробка події перевірки файлу XML", level=Qgis.Success, duration=0)
        QMessageBox.warning(self, "xml_ua:", "Вихід")
        self.handle_error_and_close("Обробка події перевірки файлу XML")

    def process_action_open(self):
        """
        Handles the action of opening an XML file.
        This method performs the following steps:
        1. Logs the action.
        2. Closes all tabs except "Структура", "Метадані", and "Ділянка".
        3. Clears existing data in TreeView and TableViews.
        4. Opens a file dialog to select an XML file.
        5. If no file is selected, shows a warning message and exits.
        6. Sets the window title to the selected file's name.
        7. Loads data from the selected XML file.
        8. Expands initial elements in the TreeView and sets the column width.
        9. Retrieves the layers_obj name from the XML layers and logs it.
        Returns:
            None
        """








        for i in reversed(range(self.tabWidget.count())):

            tab_name = self.tabWidget.tabText(i)
            widget = self.tabWidget.widget(i)


            if tab_name not in ("Структура", "Метадані", "Ділянка"):
                self.tabWidget.removeTab(i)


            else:


                if widget:

                    layout = widget.layout()
                    if layout:
                        for j in reversed(range(layout.count())):

                            layout_item = layout.itemAt(j)

                            if layout_item.widget():
                                layout_item.widget().deleteLater()
                            layout.removeItem(layout_item)









        layout = self.tabXML.layout()

        self.treeViewXML = CustomTreeView(parent=self)
        self.treeViewXML.setObjectName("treeViewXML")

        layout.addWidget(self.treeViewXML)


        layout = self.tabMetadata.layout()

        self.tableViewMetadata = TableViewMetadata(parent=self)
        self.tableViewMetadata.setObjectName("tableViewMetadata")
        self.tableViewMetadata.horizontalHeader().setStretchLastSection(True)

        layout.addWidget(self.tableViewMetadata)


        layout = self.tabParcel.layout()

        self.tableViewParcel = TableViewParcel(parent=self)
        self.tableViewParcel.setObjectName("tableViewParcel")
        self.tableViewParcel.horizontalHeader().setStretchLastSection(True)

        layout.addWidget(self.tableViewParcel)


        self.treeViewXML.model.clear()
        self.tableViewMetadata.model().clear()
        self.tableViewParcel.model().clear()



        xml_path, _ = QFileDialog.getOpenFileName(
            self, "Відкрити XML файл", "", "XML файли (*.xml)")

        if not xml_path:
            QMessageBox.warning(self, "Помилка", "Файл не вибрано.")
            return










        if not self.validate_xml_structure(xml_path):
            log_msg(logFile, "Неправильна структура файлу XML.")
            QMessageBox.warning(
                self, "Помилка", "Неправильна структура файлу XML.")
            return
        else:


            pass


        self.full_xml_file_name = xml_path



        self.current_xml.path = xml_path

        self.update_window_title(self.current_xml.path)




        self.load_data(self.full_xml_file_name, tree = None)

        self.current_xml.tree = self.treeViewXML.xml_tree


        self.treeViewXML.expand_initial_elements()
        self.treeViewXML.set_column_width(0, 75)
        self.setup_custom_tab_buttons()


        self.layers_obj = xmlUaLayers(xml_path, self.current_xml.tree, plugin=self.plugin) # Pass self.plugin


        self.current_xml.group_name = self.layers_obj.group.name()






        clone_xml = copy.deepcopy(self.current_xml)
        self.opened_xmls.append(clone_xml)



        self.plugin.connect_layer_signals()

        return


    def process_action_new(self, tree):
        """
        """
        log_calls(logFile)

        for i in reversed(range(self.tabWidget.count())):

            tab_name = self.tabWidget.tabText(i)
            widget = self.tabWidget.widget(i)

            if tab_name not in ("Структура", "Метадані", "Ділянка"):
                self.tabWidget.removeTab(i)


            else:


                if widget:

                    layout = widget.layout()
                    if layout:
                        for j in reversed(range(layout.count())):

                            layout_item = layout.itemAt(j)

                            if layout_item.widget():
                                layout_item.widget().deleteLater()
                            layout.removeItem(layout_item)









        layout = self.tabXML.layout()

        self.treeViewXML = CustomTreeView(parent=self)
        self.treeViewXML.setObjectName("treeViewXML")

        layout.addWidget(self.treeViewXML)


        layout = self.tabMetadata.layout()

        self.tableViewMetadata = TableViewMetadata(parent=self)
        self.tableViewMetadata.setObjectName("tableViewMetadata")
        self.tableViewMetadata.horizontalHeader().setStretchLastSection(True)

        layout.addWidget(self.tableViewMetadata)


        layout = self.tabParcel.layout()

        self.tableViewParcel = TableViewParcel(parent=self)
        self.tableViewParcel.setObjectName("tableViewParcel")
        self.tableViewParcel.horizontalHeader().setStretchLastSection(True)

        layout.addWidget(self.tableViewParcel)


        self.treeViewXML.model.clear()
        self.tableViewMetadata.model().clear()
        self.tableViewParcel.model().clear()



































        self.current_xml.path = xml_path

        self.update_window_title(self.current_xml.path)




        self.load_data(self.full_xml_file_name, tree = None)

        self.current_xml.tree = self.treeViewXML.xml_tree


        self.treeViewXML.expand_initial_elements()
        self.treeViewXML.set_column_width(0, 75)
        self.setup_custom_tab_buttons()







        self.layers_obj = xmlUaLayers(xml_path, self.current_xml.tree, plugin=self.plugin) # Pass self.plugin






        clone_xml = copy.deepcopy(self.current_xml)
        self.opened_xmls.append(clone_xml)

        return


    def resizeEvent(self, event):
        """
        Оновлює заголовок віджета при зміні розміру віджета.
        """
        super().resizeEvent(event)
        self.update_window_title(self.current_xml.path)

    def update_window_title(self, file_name):
        """
        Оновлює заголовок віджета, враховуючи доступну ширину та 
        обрізаючи назву файлу, якщо потрібно.
        """



        if not file_name:
            self.setWindowTitle("XML-файл обміну кадастровою інформацією")
            return



        title_width = self.width() - 80



        font_metrics = self.fontMetrics()


        elided_text = font_metrics.elidedText(
            file_name, Qt.ElideLeft, title_width)


        self.setWindowTitle(elided_text)

    def process_action_save(self):








        log_msg(logFile)

        frame = inspect.currentframe()








        if self.full_xml_file_name:
            self.treeViewXML.save_xml_tree(self.treeViewXML.xml_tree, self.full_xml_file_name)
            QMessageBox.information(None, "Успіх", f"Файл збережено: {self.full_xml_file_name}")
            return
        else:
            QMessageBox.warning(None, "Помилка", "Файл не відкритий.")
            
            return


    def process_action_save_as(self):




        log_msg(logFile)











        save_path, _ = QFileDialog.getSaveFileName(None, "Зберегти XML файл", "", "XML файли (*.xml)")
        if not save_path:
            log_calls(logFile, "Шлях для збереження не вибрано.")
            return None

        self.treeViewXML.save_xml_tree(self.treeViewXML.xml_tree, save_path)
        QMessageBox.information(self, "Успіх", f"Файл збережено: {save_path}")


    def get_tooltip_from_tree(self, full_path, default_name):
        """
        Отримує tooltip для елемента з дерева за його шляхом.
        Якщо tooltip не знайдено, повертає default_name.
        """

        tree_index = self.find_element_index(
            path=full_path)  # Пошук елемента за шляхом
        if tree_index.isValid():
            tree_item = self.treeViewXML.model.itemFromIndex(tree_index)
            if tree_item:
                return tree_item.toolTip() or default_name  # Повертає tooltip або default_name

        return default_name

    def find_element_index(self, path=None, element_name=None):
        """
        Знаходить індекс елемента у дереві на основі шляху або імені.
        """

        if path:

            current_index = QModelIndex()
            path_parts = path.split("/")  # Розділяємо шлях на частини
            for part in path_parts:
                found = False
                for row in range(self.treeViewXML.model.rowCount(current_index)):
                    child_index = self.treeViewXML.model.index(
                        row, 0, current_index)
                    child_item = self.treeViewXML.model.itemFromIndex(
                        child_index)
                    if child_item and child_item.text() == part:

                        current_index = child_index
                        found = True
                        break
                if not found:

                    return QModelIndex()
            return current_index
        elif element_name:

            for row in range(self.treeViewXML.model.rowCount()):

                item = self.treeViewXML.model.item(row, 0)
                if item and item.text() == element_name:
                    return self.treeViewXML.model.indexFromItem(item)
        return QModelIndex()

    def handle_error_and_close(self, error_message):
        """
            Обробляє помилку, відображає повідомлення і закриває док-віджет.

            Аргументи:
                Текст повідомлення про помилку.
        """
        log_msg(logFile)

        self.parent.iface.messageBar().pushCritical("Помилка", error_message)
        self.close()

    def removeTab(self, index):
        tab_name = self.tabWidget.tabText(index)
        self.tabWidget.removeTab(index)
        if tab_name in self.opened_tabs:
            self.opened_tabs.remove(tab_name)
        self.update_restore_tabs_action()

    def showEvent(self, event):
        """ 
            Відновлення вкладок при відкритті вікна 

        """





        super().showEvent(event)
        if self.plugin and not self.isVisible():
            self.restore_tabs()


    def close_tab(self, index):
        """
        Handle tab close events.
        """
        tab_name = self.tabWidget.tabText(index)

        log_msg(logFile, tab_name)
        if tab_name in ["Структура", "Метадані", "Ділянка"]:
            return

        if tab_name not in ["Структура", "Метадані", "Ділянка"]:
            self.closed_tabs.append(tab_name)
        self.removeTab(index)
        self.update_restore_tabs_action()
        self.update_tab_indices()

    def update_restore_tabs_action(self):
        """
        Оновлює стан дії "Відновити закриті вкладки".
        """
        if self.plugin:
            closed_tabs_exist = len(self.closed_tabs) > 0
            self.plugin.action_restore_tabs.setEnabled(closed_tabs_exist)

    def restore_tabs(self):
        """
        Відновлює вкладки, що були відкриті в попередній сесії.
        """
        log_calls(logFile)


        for tab_name in self.opened_tabs:
            if tab_name == "Структура":
                self.add_tab("Структура", self.tabXML)
            elif tab_name == "Метадані":
                self.add_tab("Метадані", self.tabMetadata)
            elif tab_name == "Ділянка":
                self.add_tab("Ділянка", self.tabParcel)


        for tab_name in self.closed_tabs:
            if tab_name not in self.opened_tabs:
                if tab_name not in ["Структура", "Метадані", "Ділянка"]:
                    self.opened_tabs.append(tab_name)

        self.setup_custom_tab_buttons()
        if self.plugin and hasattr(self.plugin, 'update_restore_tabs_action'):
            self.plugin.update_restore_tabs_action()

    def update_restore_tabs_action(self):
        """
        Оновлює стан дії "Відновити закриті вкладки".
        """
        if self.plugin:
            closed_tabs_exist = len(self.closed_tabs) > 0
            self.plugin.action_restore_tabs.setEnabled(closed_tabs_exist)

    def removeTab(self, index):
        tab_name = self.tabWidget.tabText(index)
        self.tabWidget.removeTab(index)
        if tab_name in self.opened_tabs:
            self.opened_tabs.remove(tab_name)
        self.update_restore_tabs_action()

    def restore_tabs(self):
        """
        Відновлює вкладки, що були відкриті в попередній сесії.
        """
        log_calls(logFile, f"closed_tabs: {self.closed_tabs}")


        for tab_name in self.closed_tabs:
            if tab_name not in self.opened_tabs:
                if tab_name == "Структура":
                    self.add_tab("Структура", self.tabXML)
                    self.load_data(self.full_xml_file_name)
                elif tab_name == "Метадані":
                    self.add_tab("Метадані", self.tabMetadata)
                    self.load_data(self.full_xml_file_name)
                elif tab_name == "Ділянка":
                    self.add_tab("Ділянка", self.tabParcel)
                    self.load_data(self.full_xml_file_name)
                else:

                    self.add_tab(tab_name, QWidget())

        self.closed_tabs.clear()
        self.setup_custom_tab_buttons()
        if self.plugin and hasattr(self.plugin, 'update_restore_tabs_action'):
            self.plugin.update_restore_tabs_action()


    def update_tab_indices(self):
        """
        Оновлює індекси вкладок після закриття.
        """

        log_calls(logFile)

        for i in range(self.tabWidget.count()):
            tab_bar = self.tabWidget.tabBar()
            tab_button = tab_bar.tabButton(i, QTabBar.RightSide)
            if tab_button:

                try:
                    connector.disconnect(tab_button, "clicked", self.tab_button_clicked)
                except TypeError:
                    pass


                tab_button.setObjectName(f"tab_close_button_{i}")

                connector.connect(tab_button, "clicked", lambda _, idx=i: self.tab_button_clicked(idx))


    def generate_layers_obj_name(self, base_name):
        """
        Формує назву групи на основі базової назви, додаючи суфікс, якщо група з такою назвою вже існує.

        Args:
            base_name (str): Базова назва групи (назва файлу без розширення).

        Returns:
            str: Назва групи.
        """
        layers_obj_name = base_name
        suffix = 0

        while self.layers_root.findGroup(layers_obj_name):
            suffix += 1
            layers_obj_name = f"{base_name}#{suffix}"

        return layers_obj_name

    def double_clicked(self, index):
        """
        Обробляє подвійне клацання на елементі в дереві шарів.
        """
        log_calls(logFile, f"index = {index}")


        item = self.iface.layerTreeView().index2node(index)

        if item is None:
            log_msg(logFile, f"item is None")
            return



        if isinstance(item, QgsLayerTreeGroup):
            layers_obj_name = item.name()
            log_msg(
                logFile, f"layers_obj_name = {layers_obj_name}")

    def clicked(self, index):
        """
        Обробляє  клацання на елементі в дереві шарів.
        """



        item = self.iface.layerTreeView().index2node(index)

        if item is None:
            log_msg(logFile, f"item is None")
            return

        if isinstance(item, QgsLayerTreeGroup):
            self.process_group_click(item.name())

    def validate_xml_structure(self, xml_path):




        mandatory_elements = [
            "AdditionalPart",
            "ServiceInfo",
            "FileID",
            "FormatVersion",
            "FileDate",
            "FileGUID",
            "ReceiverName",
            "ReceiverIdentifier",
            "Software",
            "SoftwareVersion",
            "InfoLandWork",
            "Executor",
            "CompanyName",
            "Chief",
            "Address",
            "InfoPart",
            "MetricInfo",
            "CoordinateSystem",
            "HeightSystem",
            "MeasurementUnit",
            "PointInfo",
            "Polyline",
            "ControlPoint",
            "CadastralZoneInfo",
            "CadastralZoneNumber",
            "CadastralQuarterInfo",
            "CadastralQuarterNumber",
            "ParcelInfo",
            "ParcelMetricInfo"
        ]
        try:

            tree = etree.parse(xml_path)
            root = tree.getroot()


            if root is None:
                log_msg(logFile, "Error: No root element found in the XML file.")
                return False


            if root.tag != "UkrainianCadastralExchangeFile":
                log_msg(
                    logFile, f"Error: Root element is '{root.tag}', expected 'UkrainianCadastralExchangeFile'.")
                return False

            for element_name in mandatory_elements:
                element = root.find(".//" + element_name)
                if element is None:
                    log_msg(
                        logFile, f"Error: Mandatory element '{element_name}' is missing.")
                    return False
        except Exception as e:
            log_msg(logFile, f"Error during XML structure validation: {e}")
            return False

        return True


    def process_group_click(self, group_name):





        log_calls(logFile, group_name)

        if not hasattr(self, 'opened_xmls'):
            QMessageBox.warning(self, "process_group_click()",
                                "not hasattr(self, 'opened_xmls')")
            log_msg(logFile, "Error: opened_xmls attribute is not initialized.")
            return

        layers_root = QgsProject.instance().layerTreeRoot()
        clicked_group = layers_root.findGroup(group_name)

        if not clicked_group:
            log_msg(
                logFile, f"Group '{group_name}' not found in the layer tree")
            return


        found = False
        for xml in self.opened_xmls:
            if xml.group_name == group_name:
                self.current_xml = xml
                found = True
                log_msg(logFile, f"Group '{group_name}' found in opened_xmls")

                break

        if not found:
            log_msg(logFile, f"Нема відкритого xml з іменем '{group_name}'")
            return

        if self.isHidden():
            self.show()


        self.plugin.clear_widget_data()

        self.load_data(self.current_xml.path, self.current_xml.tree)
        self.treeViewXML.expand_initial_elements()
        self.treeViewXML.set_column_width(0, 75)


        self.treeViewXML.expand_initial_elements()
        self.treeViewXML.set_column_width(0, 75)
        self.setup_custom_tab_buttons()


        self.update_window_title(self.current_xml.path)
































    def update_xml_with_new_geometry(self, layer, feature_id, geometry):
        """
        Оновлює XML-файл на основі нової геометрії.
        """

        log_calls(logFile)


        feature = layer.getFeature(feature_id)
        if not feature:
            log_msg(logFile, f"Фіча з ID {feature_id} не знайдена в шарі {layer.name()}.")
            return


        new_geometry = feature.geometry()
        log_calls(logFile, f"Нова геометрія фічі: {geometry_to_string(new_geometry)}")



        QMessageBox.information(self, "update_xml_with_new_geometry()", f"Нова геометрія фічі: {geometry_to_string(new_geometry)}")
        
