# -*- coding: utf-8 -*-
# dockwidget.py
"""
/***************************************************************************
 xml_uaDockWidget
                                 A QGIS plugin
 Processing ukrainian cadastral files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-01
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Michael.Krechkivski@gmail.com
        email                : michael.krechkivski@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#✔️ 2025.10.02 15:16 Видалення групи пов'язаної з відкритим xml файлом 
# повинно супроводжуватися закриттям відповідної вкладки доквіджета


# region Import
import os
import inspect
import copy
import shutil
import uuid
import math
import re
from datetime import datetime

from lxml import etree

from qgis.PyQt import uic

from qgis.PyQt.QtGui import QIcon

from qgis.PyQt.QtCore import QModelIndex
from qgis.PyQt.QtCore import QVariant
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtCore import QSize
from qgis.PyQt.QtCore import QTimer
from qgis.PyQt.QtCore import Qt

from qgis.core import Qgis
from qgis.core import QgsLayerTreeGroup
from qgis.core import QgsLayerTreeLayer
from qgis.core import QgsProject
from qgis.core import QgsVectorLayer
from qgis.core import QgsFeature
from qgis.core import QgsField
from qgis.core import QgsPointXY
from qgis.core import QgsWkbTypes
from qgis.core import QgsGeometry
from qgis.core import QgsTask, QgsApplication
from qgis.core import QgsLayerTreeModel

from qgis.gui import QgsLayerTreeView


from qgis.PyQt.QtWidgets import QDockWidget
from qgis.PyQt.QtWidgets import QWidget
from qgis.PyQt.QtWidgets import QVBoxLayout
from qgis.PyQt.QtWidgets import QHBoxLayout
from qgis.PyQt.QtWidgets import QMenu
from qgis.PyQt.QtWidgets import QAction
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.PyQt.QtWidgets import QLayout
from qgis.PyQt.QtWidgets import QToolButton
from qgis.PyQt.QtWidgets import QStyle
from qgis.PyQt.QtWidgets import QTreeView
from qgis.PyQt.QtWidgets import QFileDialog
from qgis.PyQt.QtWidgets import QTableView
from qgis.PyQt.QtWidgets import QInputDialog

from qgis.PyQt.QtWidgets import QTabWidget, QStyleOption, QWidget, QStyle, QPushButton, QTabBar
from qgis.PyQt.QtGui import QPainter, QIcon, QPalette
from qgis.PyQt.QtCore import QSettings

from .tree_view import CustomTreeView
from .delegates import DispatcherDelegate, DocumentCodeDelegate
#from .metadata import TableViewMetadata
#from .parcel import TableViewParcel
from .layers import xmlUaLayers

from .common import logFile
from .common import log_msg
from .topology import GeometryProcessor
from .common import geometry_to_string
from .common import size
from .common import xsd_path
from .common import connector
from .topology import GeometryProcessor

class BackupTask(QgsTask):
    """Фонове завдання для створення резервної копії файлу."""
    def __init__(self, source_path, dest_path, description, dockwidget):
        super().__init__(description, QgsTask.CanCancel)
        self.source_path = source_path
        self.dest_path = dest_path
        self.dockwidget = dockwidget
        self.exception = None

    def run(self):
        """Виконує копіювання файлу."""
        try:
            if self.isCanceled():
                return False
            
            shutil.copy2(self.source_path, self.dest_path)
            return True
        except Exception as e:
            self.exception = e
            return False

    def finished(self, result):
        """Обробляє завершення завдання."""
        # Безпечно видаляємо завдання зі списку активних завдань
        if self.dockwidget and self in self.dockwidget.running_tasks:
            self.dockwidget.running_tasks.remove(self)

        # Використовуємо iface з док-віджета
        iface = self.dockwidget.iface if self.dockwidget else qgis.utils.iface
        if result:
            # log_msg(logFile, f"Створено резервну копію: {self.dest_path}")
            iface.messageBar().pushMessage("Інфо", f"Створено резервну копію: {os.path.basename(self.dest_path)}", level=Qgis.Info, duration=3)
        else:
            if self.exception:
                log_msg(logFile, f"Не вдалося створити резервну копію для {self.source_path}: {self.exception}")
                QMessageBox.warning(iface.mainWindow(), "Помилка", f"Не вдалося створити резервну копію файлу: {self.exception}")
            else:
                log_msg(logFile, f"Створення резервної копії скасовано: {self.source_path}")



FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'xml_ua_dockwidget_base.ui'))


class xml_uaDockWidget(QDockWidget, FORM_CLASS):


    closingPlugin = pyqtSignal()




    def __init__(self, parent=None, iface=None, plugin=None):

        # parent -> QMainWindow
        # виконується лише після відкриття файла -> ❓❓❓

        super().__init__(parent)

        # інтерфейс QGIS
        self.iface = iface

        self.plugin = plugin
        # Читаємо дизайн UI з файлу xml_ua_dockwidget_base.ui
        self.setupUi(self)
        self.parent = parent

        # --- Початок змін: Встановлення початкової ширини віджета ---
        self.resize(400, self.height())
        # --- Кінець змін ---
        # Створюємо порожній список відкритих xml-файлів
        self.opened_xmls = []

        # ініціалізація атрибутів
        self.full_xml_file_name = None
        self.layers_obj = None
        self.full_xml_file_name = ""

        # Флаг для блокування рекурсивних викликів при закритті
        self._is_closing = False

        # Налаштування QTabWidget
        self.tabWidget.setMovable(True)  # Дозволяємо переміщення вкладок
        self.tabWidget.setTabsClosable(False) # Вимикаємо стандартні кнопки, будемо використовувати кастомні
        # Видаляємо початкові вкладки, створені з .ui файлу
        while self.tabWidget.count() > 0:
            self.tabWidget.removeTab(0)

        self.setWindowTitle("xml_ua")

        # Створюємо об'єкт даних xml, який відображається у доквіджеті
        # self.current_xml = self.xml_data(path="", tree=None, group_name=None)

        # Тут лише ініціалізуємо змінну current_xml
        # Створювати об'єкт xml_data будемо при відкритті файлу 
        # або при cтворенні нового xml
        self.current_xml = None
        
        # Сигнали для вкладок
        # connector.connect(self.tabWidget, "tabCloseRequested", self.close_tab) # Більше не використовується
        connector.connect(self.tabWidget, "currentChanged", self.on_tab_changed)

        # Підключаємо сигнали дерева шарів
        self.connect_layer_tree_signals()
        # --- Початок змін: Виправлення помилки 'nodeRemoved' ---
        connector.connect(QgsProject.instance(), "layerWillBeRemoved", self.on_layer_will_be_removed)

        # Завантажуємо іконку для збереження один раз
        self.save_icon = self.style().standardIcon(QStyle.SP_DialogSaveButton)

        # Словник для зберігання посилань на кнопки збереження на вкладках
        self.tab_save_buttons = {}

        # Список для зберігання посилань на активні фонові завдання
        self.running_tasks = []



    class xml_data:


        # Всередині класу xml_data створюємо клас xml_geometry
        # для зберігання "старої" геометрії XML, яка недоступна
        # у сигналах QGIS по зміні геометрії


        class xml_geometry:
            """
            Клас для зберігання геометрії XML.
            """

            # Конструктор класу xml_geometry
            def __init__(self, geometry: str = ""):
                self.points = []
                self.lines = []
                self.zone = None
                self.quarter = None
                self.parcel = None
                self.lands = []
                self.leases = []
                self.subleases = []
                self.restrictions = []
                self.adjacents = []


        # Конструктор класу xml_data
        def __init__(self, path: str = "", tree: object = None, group_name: str = "", backup_path: str = ""):
            self.original_path = "" # Шлях до файлу без часової мітки
            self.path = path
            self.tree = tree
            self.group_name = group_name
            self.geom = self.xml_geometry()
            self.backup_path = backup_path
            self.temp_tree_state = None
            self.changed = False
            # --- Початок змін: Новий прапорець для відстеження змін ---
            self.was_ever_changed = False # Відстежує, чи були зміни взагалі


        def __deepcopy__(self, memo):
            """
            Deep copy implementation for xml_data objects.
            """
            cls = self.__class__
            result = cls.__new__(cls)
            memo[id(self)] = result
            for k, v in self.__dict__.items():
                if k == "tree":
                    setattr(result, k, copy.deepcopy(v, memo))
                else:
                    setattr(result, k, copy.deepcopy(v, memo))
            return result


    def connect_layer_tree_signals(self):
        """Підключає сигнали від дерева шарів до слотів цього віджета."""
        # log_msg(logFile, "Підключення сигналів дерева шарів.")
        connector.connect(self.iface.layerTreeView(), "doubleClicked", self.double_clicked)
        connector.connect(self.iface.layerTreeView(), "clicked", self.clicked)


    def disconnect_layer_tree_signals(self):
        """Відключає сигнали від дерева шарів."""
        log_msg(logFile, "Відключення сигналів дерева шарів.")
        connector.disconnect(self.iface.layerTreeView(), "doubleClicked", self.double_clicked)
        connector.disconnect(QgsProject.instance(), "layerWillBeRemoved", self.on_layer_will_be_removed)
        connector.disconnect(self.iface.layerTreeView(), "clicked", self.clicked)

    def load_data(self, xml_path, tree = None):

        # При виклику з process_group_click tree != None
        # При виклику з process_action_open tree == None

        # Знаходимо поточну вкладку та її дерево
        current_tab_widget = self.tabWidget.currentWidget()
        if not current_tab_widget: return
        tree_view = current_tab_widget.findChild(CustomTreeView)
        if not tree_view: return

        tree_view.load_xml_to_tree_view(xml_path, xsd_path, tree)
        self.current_xml.tree = tree_view.xml_tree # type: ignore

        return


    def process_action_check(self):
        """Перевіряє поточний активний XML-файл."""
        current_tab_widget = self.tabWidget.currentWidget()
        if not self.current_xml or not current_tab_widget:
            QMessageBox.warning(self, "Помилка", "Немає активного XML-файлу для перевірки.")
            return

        tree_view = current_tab_widget.findChild(CustomTreeView)
        if not tree_view:
            QMessageBox.warning(self, "Помилка", "Не знайдено дерево XML для перевірки.")
            return

        # Попередження для користувача
        reply = QMessageBox.question(self, 'Перевірка XML',
                                     "Перевірка файлу на відповідність схемі може зайняти деякий час. Продовжити?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            log_msg(logFile, f"Запуск повної валідації для файлу: {self.current_xml.path}")
            self.iface.messageBar().pushMessage("xml_ua:", f"Перевірка файлу: {os.path.basename(self.current_xml.path)}...", level=Qgis.Info, duration=5)
            
            # Запускаємо валідацію з генерацією звіту
            errors_list = tree_view._validate_and_color_tree(generate_report=True)
            
            if errors_list:
                # Зберігаємо звіт
                report_path = os.path.join(os.path.dirname(self.current_xml.path), f"Check_{os.path.basename(self.current_xml.path)}.txt")
                try:
                    with open(report_path, 'w', encoding='utf-8') as f:
                        f.write(f"Звіт про помилки для файлу: {self.current_xml.path}\n")
                        f.write("="*50 + "\n")
                        for i, error in enumerate(errors_list, 1):
                            f.write(f"{i}. {error}\n")
                            # Послідовно виводимо кожну помилку на панель повідомлень
                            self.iface.messageBar().pushMessage(
                                f"Помилка валідації #{i}", error, level=Qgis.Warning, duration=0)
                    
                    log_msg(logFile, f"Знайдено {len(errors_list)} помилок. Звіт збережено у '{report_path}'.")
                except Exception as e:
                    log_msg(logFile, f"Не вдалося зберегти звіт про помилки: {e}")
                    QMessageBox.critical(self, "Помилка", f"Не вдалося зберегти звіт про помилки: {e}")
            else:
                self.iface.messageBar().pushMessage("xml_ua:", f"Перевірку файлу '{os.path.basename(self.current_xml.path)}' завершено. Помилок не знайдено.", level=Qgis.Success, duration=5)
                log_msg(logFile, "Валідацію завершено. Помилок не знайдено.")
        else:
            log_msg(logFile, "Перевірку скасовано користувачем.")


    def process_action_open(self):
        
        """
        Handles the action of opening an XML file.
        This method performs the following steps:
        1. Logs the action.
        2. Closes all tabs except "Структура", "Реквізити", and "Ділянка".
        3. Clears existing data in TreeView and TableViews.
        4. Opens a file dialog to select an XML file.
        5. If no file is selected, shows a warning message and exits.
        6. Sets the window title to the selected file's name.
        7. Loads data from the selected XML file.
        8. Expands initial elements in the TreeView and sets the column width.
        9. Retrieves the layers_obj name from the XML layers and logs it.
        Returns:
            None
        """

        # region відкриваємо файл XML

        xml_path, _ = QFileDialog.getOpenFileName(
            self, "Відкрити XML файл", "", "XML файли (*.xml)")

        if not xml_path:
            QMessageBox.warning(self, "Помилка", "Файл не вибрано.")
            return

        # TODO: тут поки неповна шивка перевірка
        # if not self.validate_xml_structure(xml_path):
        #     # TODO: тут треба виводити помилку на панелі QGIS - 
        #     # чому саме validate_xml_structure видала False
        #     # для цього її логіка роботи: визначення помилок
        #     # замість validate_xml_structure вона повинна 
        #     # називатися errors_list ==> [] якщо все ок
        #     log_msg(logFile, "Неправильна структура файлу XML.")
        #     # Виводимо попередження про помилку на панелі QGIS
        #     self.iface.messageBar().pushMessage(
        #                         "xml_ua:", 
        #                         "Неправильна структура файлу XML.", 
        #                         level=Qgis.Critical, 
        #                         duration=0)
            
        #     return
        # else:
        #     # log_msg(logFile, "Файл відповідає структурі XML.")
        #     # Виводимо повідомлення про успіх на панелі QGIS
        #     self.iface.messageBar().pushMessage(
        #                         "xml_ua:", 
        #                         "Файл відповідає структурі XML.", 
        #                         level=Qgis.Success, 
        #                         duration=5)
        #     pass
        # endregion
        
        # --- Початок змін: Оновлена логіка резервного копіювання ---
        dir_name = os.path.dirname(xml_path)
        file_basename, ext = os.path.splitext(os.path.basename(xml_path))

        # Регулярний вираз для пошуку часової мітки в імені файлу
        timestamp_pattern = r"(.+?)_(\d{4}\.\d{2}\.\d{2}\.\d{2}\.\d{2}(?:\.\d{2})?)$"
        match = re.match(timestamp_pattern, file_basename)

        now = datetime.now()
        original_path = xml_path
        
        if match:
            # Файл вже є резервною копією
            base_name = match.group(1)
            old_timestamp_str = match.group(2)
            
            # Перевіряємо, чи зміни відбуваються в ту ж хвилину
            if old_timestamp_str == now.strftime('%Y.%m.%d.%H.%M'):
                # Додаємо секунди
                new_timestamp = now.strftime('%Y.%m.%d.%H.%M.%S')
            else:
                new_timestamp = now.strftime('%Y.%m.%d.%H.%M')
            backup_path = os.path.join(dir_name, f"{base_name}_{new_timestamp}{ext}")
            original_path = os.path.join(dir_name, f"{base_name}{ext}")
        else:
            # Це звичайний файл, створюємо першу резервну копію
            new_timestamp = now.strftime('%Y.%m.%d.%H.%M')
            backup_path = os.path.join(dir_name, f"{file_basename}_{new_timestamp}{ext}")
            original_path = xml_path

        # Створюємо та запускаємо фонове завдання
        task_description = f"Створення резервної копії для {os.path.basename(xml_path)}"
        backup_task = BackupTask(xml_path, backup_path, task_description, self)
        self.running_tasks.append(backup_task) # Зберігаємо посилання на завдання
        QgsApplication.taskManager().addTask(backup_task) # Додаємо завдання до менеджера

        self.open_xml_file(xml_path, backup_path, original_path)
        # --- Кінець змін ---

    def open_xml_file(self, xml_path, backup_path=None, original_path=None):
        """Відкриває XML файл, створює вкладку та шари."""
        # --- Початок змін: Логування відкриття файлу ---
        current_time = datetime.now().strftime("%H:%M:%S")
        log_msg(logFile, f"[{current_time}] Відкриття файлу: {os.path.basename(xml_path)}")
        # --- Кінець змін ---

        # Якщо файл відкривається не через process_action_open (напр. при відновленні),
        # backup_path може бути None. У такому випадку ми не створюємо нову резервну копію.
        if backup_path is None:
            # Якщо backup_path не надано, ми все одно продовжуємо, але не створюємо нову копію.
            pass

        # Створюємо новий об'єкт xml_data
        new_xml_data = self.xml_data(path=xml_path, tree=None, group_name="", backup_path=backup_path) # type: ignore
        new_xml_data.original_path = original_path
        self.current_xml = new_xml_data

        # Створюємо нову вкладку
        new_tab = QWidget()
        layout = QVBoxLayout(new_tab)
        tree_view = CustomTreeView(parent=self)
        layout.addWidget(tree_view)
        new_tab.setLayout(layout)

        # Додаємо вкладку
        index = self.tabWidget.addTab(new_tab, os.path.basename(xml_path))
        self.tabWidget.setCurrentIndex(index)

        # Зберігаємо посилання на дерево у об'єкті xml_data
        self.current_xml.tree_view = tree_view # type: ignore

        # Завантажуємо дані
        self.load_data(xml_path, tree=None)

        # Оновлюємо дерево
        tree_view.expand_initial_elements()
        # --- Початок змін: Встановлення фіксованої ширини колонки ---
        tree_view.setColumnWidth(0, 300)
        # --- Кінець змін ---

        # ініціалізуємо заповнення шарів, передаючи xml_data
        self.layers_obj = xmlUaLayers(xml_path, self.current_xml.tree, plugin=self.plugin, xml_data=self.current_xml) # Pass self.plugin
        self.current_xml.group_name = self.layers_obj.group.name()

        # Оновлюємо назву вкладки на назву групи
        self.tabWidget.setTabText(index, self.current_xml.group_name)
        self.tabWidget.setTabToolTip(index, xml_path)

        # Спочатку налаштовуємо кнопки
        # --- Початок змін: Запобігання показу прихованого віджета ---
        # Якщо віджет прихований, ми не хочемо, щоб додавання вкладки
        # робило його видимим.
        if not self.isVisible():
            self.tabWidget.setCurrentIndex(-1) # Скидаємо активну вкладку, щоб уникнути візуальних артефактів
        # --- Кінець змін ---
        self.setup_custom_tab_buttons()

        # Встановлюємо початковий стан вкладки (кнопка збереження неактивна)
        self.update_tab_save_button_state(index, is_enabled=False)
        self.opened_xmls.append(self.current_xml)

        # Показуємо інформацію про площу після створення всіх шарів
        self.update_all_actions_state(is_file_open=True)
        self.update_changed_actions_state(is_changed=False)

    def show_parcel_area_info(self):
        """Обчислює та показує інформацію про площу ділянки та вузли."""
        if not self.current_xml or self.current_xml.tree is None:
            return

        try:
            from .validators import compute_parcel_area
            tree = self.current_xml.tree

            # Обчислення площі (м² -> га) і форматування
            area_m2 = compute_parcel_area(tree)
            area_ha = area_m2 / 10000.0
            area_str = f"{area_ha:.4f}"

            # Перевірка, чи потрібно показувати діалог
            show_dialog = False
            area_elements = tree.findall(".//ParcelMetricInfo/Area/Size")
            if not area_elements:
                show_dialog = True # Показуємо, якщо площі взагалі немає
            else:
                for size_elem in area_elements:
                    try:
                        xml_area_ha = float(size_elem.text)
                        if round(xml_area_ha, 4) != round(area_ha, 4):
                            show_dialog = True
                            break
                    except (ValueError, TypeError):
                        show_dialog = True # Показуємо, якщо значення площі некоректне

            # Формуємо основні рядки повідомлення
            message_lines = []
            message_lines.append(f"Площа обчислена за координатами вузлів: {area_str} га")

            # Перевіряємо наявність ExhangeFileCoordinates
            exchange_coords_elem = tree.find(".//ParcelMetricInfo/Area/DeterminationMethod/ExhangeFileCoordinates")
            if exchange_coords_elem is not None:
                size = tree.findtext(".//ParcelMetricInfo/Area/Size", "N/A")
                unit = tree.findtext(".//ParcelMetricInfo/Area/MeasurementUnit", "")
                message_lines.append(f"За координатами обмінного файлу: {size} {unit}".strip())

            # Перевіряємо наявність DocExch
            doc_exch_elem = tree.find(".//ParcelMetricInfo/Area/DeterminationMethod/DocExch")
            if doc_exch_elem is not None:
                size = tree.findtext(".//ParcelMetricInfo/Area/Size", "N/A")
                unit = tree.findtext(".//ParcelMetricInfo/Area/MeasurementUnit", "")
                message_lines.append(f"Згідно із правовстановлювальним документом: {size} {unit}".strip())

            # Збирання впорядкованого списку UIDP для зовнішнього контуру
            polylines = {}
            for pl in tree.findall(".//MetricInfo/Polyline/PL"):
                ulid = pl.findtext("ULID")
                pts = [p.text for p in pl.findall("Points/P")]
                if ulid:
                    polylines[ulid] = pts

            boundary_lines_ulids = [
                ln.findtext("ULID")
                for ln in tree.findall(".//ParcelMetricInfo/Externals/Boundary/Lines/Line")
                if ln.findtext("ULID")
            ]

            ordered_uidp = []
            if boundary_lines_ulids:
                first = boundary_lines_ulids[0]
                ordered_uidp.extend(polylines.get(first, []))
                for ulid in boundary_lines_ulids[1:]:
                    pts = polylines.get(ulid, [])
                    if not pts: continue
                    
                    if ordered_uidp and pts[0] == ordered_uidp[-1]:
                        ordered_uidp.append(pts[1] if len(pts) > 1 else pts[0])
                    elif ordered_uidp and pts[-1] == ordered_uidp[-1]:
                        ordered_uidp.append(pts[0])
                    else:
                        for candidate in pts:
                            if candidate not in ordered_uidp:
                                ordered_uidp.append(candidate)
                                break

            nodes_text = ", ".join(ordered_uidp) if ordered_uidp else "не знайдено."
            message_lines.append(f"Номери вузлів: {nodes_text}")

            # Формуємо заголовок та фінальне повідомлення
            title = f"Площа ділянки: {os.path.basename(self.current_xml.path)}"
            full_message = "\n".join(message_lines)
            if show_dialog:
                QMessageBox.information(self, title, full_message)
        except Exception as e:
            log_msg(logFile, f"Помилка під час показу інформації про площу ділянки: {e}")

    def log_opened_xmls(self):
        """
        Logs the opened XML files.
        """        
        # Ця логіка більше не потрібна в такому вигляді
        pass


    def process_action_new(self, xml_path, tree):
        """
        """
        # Процес створення нового xml
        # У цьому місці користувач вибравши пункт 
        # меню "Новий" вибрав папку і назву файлу 
        # шаблон зчитаний і розпарсений ???
        # треба зберегти дерево xml на диск і відкрити 
        # відкрити його без перевіоки наявності всіх
        # обов'язкових елементів схеми оскільки файл
        # у процесі розробки
        
        log_msg(logFile)

        # Створюємо новий об'єкт xml_data
        new_xml_data = self.xml_data(path=xml_path, tree=tree, group_name="")
        self.current_xml = new_xml_data

        # Створюємо нову вкладку
        new_tab = QWidget()
        layout = QVBoxLayout(new_tab)
        tree_view = CustomTreeView(parent=self)
        layout.addWidget(tree_view)
        new_tab.setLayout(layout)

        # Додаємо вкладку
        index = self.tabWidget.addTab(new_tab, os.path.basename(xml_path))
        self.tabWidget.setCurrentIndex(index)

        # Зберігаємо посилання на дерево у об'єкті xml_data
        self.current_xml.tree_view = tree_view

        # Завантажуємо дані
        self.load_data(xml_path, tree=tree)

        # Оновлюємо дерево
        tree_view.expand_initial_elements()
        # --- Початок змін: Встановлення фіксованої ширини колонки ---
        tree_view.setColumnWidth(0, 300)
        # --- Кінець змін ---

        # ініціалізуємо заповнення шарів
        self.layers_obj = xmlUaLayers(xml_path, self.current_xml.tree, plugin=self.plugin, xml_data=self.current_xml)
        self.current_xml.group_name = self.layers_obj.group.name()

        # Оновлюємо назву вкладки на назву групи
        self.tabWidget.setTabText(index, self.current_xml.group_name)
        self.tabWidget.setTabToolTip(index, xml_path)

        # Спочатку налаштовуємо кнопки, щоб вони були створені
        self.setup_custom_tab_buttons()

        # Встановлюємо початковий стан вкладки (кнопка збереження неактивна)
        self.update_tab_save_button_state(index, is_enabled=False)
        self.opened_xmls.append(self.current_xml)
        
        self.current_xml.path = xml_path
        self.update_all_actions_state(is_file_open=True)
        self.update_changed_actions_state(is_changed=False)
        self.update_window_title(self.current_xml.path)

        # Явно виділяємо новостворену групу в дереві шарів
        layers_root = QgsProject.instance().layerTreeRoot()
        group = layers_root.findGroup(self.current_xml.group_name)
        if group:
            self.iface.layerTreeView().setCurrentNode(group)
            log_msg(logFile, f"Новостворену групу '{self.current_xml.group_name}' виділено.")

        return


    def resizeEvent(self, event):
        """
        Оновлює заголовок віджета при зміні розміру віджета.
        """
        super().resizeEvent(event)
        self.update_window_title(self.full_xml_file_name)


    def update_window_title(self, file_name):
        """
        Оновлює заголовок віджета, враховуючи доступну ширину та 
        обрізаючи назву файлу, якщо потрібно.
        """
        self.setWindowTitle("xml_ua")

    def update_tab_save_button_state(self, index, is_enabled):
        """Робить кнопку збереження на вкладці активною або неактивною."""
        button = self.tab_save_buttons.get(index)
        if button:
            button.setEnabled(is_enabled)

    def update_tab_style_by_group_name(self, group_name, is_changed):
        """Знаходить вкладку за іменем групи та оновлює її стиль."""
        for i in range(self.tabWidget.count()):
            if self.tabWidget.tabText(i) == group_name:
                self.update_tab_save_button_state(i, is_enabled=is_changed)
                return True
        return False

    def mark_as_changed(self):
        """
        Позначає поточний XML-файл як змінений і оновлює заголовок вікна.
        """
        if self.current_xml and not self.current_xml.changed:
            log_msg(logFile, f"Файл '{self.current_xml.path}' позначено як змінений.")
            self.current_xml.changed = True
            # --- Початок змін: Встановлення нового прапорця ---
            self.current_xml.was_ever_changed = True # Фіксуємо, що зміни були
            # Оновлюємо стиль вкладки, щоб показати зміни
            self.update_tab_style_by_group_name(self.current_xml.group_name, is_changed=True)
            # Вмикаємо кнопку "Зберегти"
            self.update_changed_actions_state(is_changed=True)

    def process_action_save(self):
        """Зберігає вибраний XML-файл."""
        log_msg(logFile, "Спроба зберегти XML.")

        xml_to_save = self.select_xml_to_save("Вибір групи для збереження")
        if not xml_to_save:
            return  # Користувач скасував або виникла помилка

        # Запитуємо підтвердження у користувача, тільки якщо є зміни
        reply = QMessageBox.Yes
        if xml_to_save.changed:
            reply = QMessageBox.question(self, 'Підтвердження збереження', f"Зберегти зміни для групи '{xml_to_save.group_name}' у файл:\n\n{xml_to_save.path}?", QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

        if reply == QMessageBox.Yes:
            # --- Початок змін: Збереження в обидва файли ---
            # 1. Зберігаємо у файл, що редагується (з часовою міткою)
            xml_to_save.tree_view.save_xml_tree(xml_to_save.tree, xml_to_save.path)
            log_msg(logFile, f"Файл, що редагується, збережено: {xml_to_save.path}")

            # 2. Зберігаємо в оригінальний файл (без часової мітки)
            if xml_to_save.original_path and xml_to_save.original_path != xml_to_save.path:
                xml_to_save.tree_view.save_xml_tree(xml_to_save.tree, xml_to_save.original_path)
                log_msg(logFile, f"Оригінальний файл оновлено: {xml_to_save.original_path}")
                self.iface.messageBar().pushMessage("Диск:", f"Файли '{os.path.basename(xml_to_save.original_path)}' та '{os.path.basename(xml_to_save.path)}' збережено.", level=Qgis.Success, duration=5)
            else:
                self.iface.messageBar().pushMessage("Диск:", f"Файл збережено: {xml_to_save.path}", level=Qgis.Success, duration=5)
            # --- Кінець змін ---

            # Позначаємо, що зміни збережено
            xml_to_save.changed = False
            # Оновлюємо заголовок вкладки, щоб прибрати '*'
            if self.update_tab_style_by_group_name(xml_to_save.group_name, is_changed=False) and xml_to_save == self.current_xml:
                self.update_changed_actions_state(is_changed=False)
            self.update_window_title(xml_to_save.path)
        else:
            log_msg(logFile, "Збереження скасовано користувачем.")

    def process_action_save_as_template(self):
        """Створює та зберігає шаблон на основі поточного XML-файлу."""
        log_msg(logFile, "Запуск створення шаблону.")

        xml_to_save = self.current_xml
        if not xml_to_save:
            QMessageBox.warning(self, "Помилка", "Немає активного файлу для створення шаблону.")
            return

        # Діалог для введення назви шаблону
        prompt_text = (
            "Введіть назву, яка буде відображати особливості атрибутивних та просторових характеристик.\n"
            "Наприклад, назва <Рада>_<зона>_<орендар> дозволить у майбутньому легко знайти збережений шаблон\n"
            "у списку і створити новий обмінний файл без повторного заповнення атрибутів."
        )
        template_name, ok = QInputDialog.getText(self, "Зберегти як шаблон", prompt_text)

        if not ok or not template_name.strip():
            log_msg(logFile, "Створення шаблону скасовано користувачем.")
            return

        # --- Початок змін: Надійне копіювання дерева через серіалізацію ---
        # Використання copy.deepcopy з lxml може призводити до збоїв через проблеми з управлінням пам'яттю.
        # Серіалізація в рядок і зворотний парсинг створює повністю незалежну копію.
        tree_string = etree.tostring(xml_to_save.tree.getroot(), encoding='utf-8', xml_declaration=True)
        template_tree = etree.ElementTree(etree.fromstring(tree_string))
        # --- Кінець змін ---
        
        # Обнуляємо геометрію
        self._create_template_from_tree(template_tree)

        # Зберігаємо файл у папку templates
        templates_dir = os.path.join(os.path.dirname(__file__), 'templates')
        if not os.path.exists(templates_dir):
            os.makedirs(templates_dir)
        
        template_path = os.path.join(templates_dir, f"{template_name.strip()}.xml")

        try:
            template_tree.write(template_path, encoding="utf-8", xml_declaration=True)
            self.iface.messageBar().pushMessage("Диск:", f"Шаблон '{template_name}' успішно збережено.", level=Qgis.Success, duration=5)
            log_msg(logFile, f"Шаблон збережено: {template_path}")
            # Оновлюємо контекстне меню карти
            self.plugin.reload_map_canvas_context()
        except Exception as e:
            log_msg(logFile, f"Помилка при збереженні шаблону: {e}")
            QMessageBox.critical(self, "Помилка", f"Не вдалося зберегти шаблон: {e}")

    def _create_template_from_tree(self, tree):
        """Обнуляє геометрію в XML-дереві, залишаючи атрибути."""
        root = tree.getroot()

        # Видаляємо всі точки та полілінії
        for parent in root.xpath(".//PointInfo | .//Polyline"):
            for child in parent.xpath("./*"):
                parent.remove(child)

        # Очищуємо всі геометричні межі
        for boundary_container in root.xpath(".//Externals | .//Internals"):
            for child in boundary_container.xpath("./*"):
                boundary_container.remove(child)

        # Залишаємо тільки перший дочірній елемент для списків
        paths_to_prune = [
            ".//LandsParcel",
            ".//Leases",
            ".//Subleases",
            ".//Restrictions",
            ".//AdjacentUnits"
        ]
        for path in paths_to_prune:
            parent_element = root.find(path)
            if parent_element is not None:
                children = list(parent_element)
                if len(children) > 1:
                    for child_to_remove in children[1:]:
                        parent_element.remove(child_to_remove)
        return tree

    def select_xml_to_save(self, title: str):
        """
        Визначає, який XML-файл зберегти. Якщо відкрито більше одного,
        показує діалог вибору.
        """
        count = self.tabWidget.count()
        if count == 0:
            QMessageBox.warning(self, "Помилка", "Немає відкритих XML-файлів для збереження.")
            return None

        if count > 1:
            tab_names = [self.tabWidget.tabText(i) for i in range(count)]
            current_tab_index = self.tabWidget.currentIndex()

            tab_to_save, ok = QInputDialog.getItem(self, title,
                                                     "Виберіть вкладку, яку потрібно зберегти:",
                                                     tab_names, current_tab_index, False)
            if not ok or not tab_to_save:
                log_msg(logFile, "Збереження скасовано користувачем (вибір вкладки).")
                return None

            for i in range(count):
                if self.tabWidget.tabText(i) == tab_to_save:
                    return self.get_xml_data_for_tab_index(i)
        elif count == 1:
            return self.get_xml_data_for_tab_index(0)

        return None

    def process_action_close_xml(self, xml_to_close=None, group_already_removed=False, force_close=False):
        """Закриває вказаний XML-файл та пов'язану з ним групу шарів."""
        if self._is_closing:
            return
        self._is_closing = True
        
        try:
            if not xml_to_close:
                xml_to_close = self.current_xml
    
            # Якщо немає чого закривати, виходимо
            if not xml_to_close:
                self._is_closing = False
                return
    
            # Запитуємо підтвердження, якщо є незбережені зміни
            if not force_close and xml_to_close and xml_to_close.changed:
                reply = QMessageBox.question(self, 'Підтвердження закриття',
                                             f"Файл для групи '{xml_to_close.group_name}' має незбережені зміни. \n\nЗакрити без збереження?",
                                             QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
                if reply == QMessageBox.No:
                    self._is_closing = False
                    return # Користувач скасував закриття
    
            # --- Початок змін: Оновлена логіка видалення резервної копії ---
            # Видаляємо резервну копію, тільки якщо файл НЕ змінювався взагалі.
            # Якщо були будь-які зміни (збережені чи ні), копія залишається.
            if not xml_to_close.was_ever_changed:
                try:
                    if xml_to_close.backup_path and os.path.exists(xml_to_close.backup_path):
                        os.remove(xml_to_close.backup_path)
                        log_msg(logFile, f"Резервну копію '{xml_to_close.backup_path}' видалено, оскільки файл не було змінено.")
                        self.iface.messageBar().pushMessage("Інфо", f"Резервну копію для '{os.path.basename(xml_to_close.path)}' видалено.", level=Qgis.Info, duration=3)
                except (OSError, TypeError) as e:
                    log_msg(logFile, f"Не вдалося видалити резервну копію '{xml_to_close.backup_path if xml_to_close.backup_path else 'None'}': {e}")
            # --- Кінець змін ---
            # --- Початок змін: Виправлення краху при закритті ---
            # 1. Знаходимо індекс вкладки, яку будемо видаляти
            tab_index_to_remove = -1
            for i in range(self.tabWidget.count()):
                if self.tabWidget.tabText(i) == xml_to_close.group_name:
                    tab_index_to_remove = i
                    break

            # 2. Видаляємо об'єкт xml_data зі списку та очищуємо посилання на нього.
            # Це потрібно зробити ДО видалення вкладки, щоб уникнути доступу до знищеного об'єкта.
            if xml_to_close in self.opened_xmls:
                self.opened_xmls.remove(xml_to_close)
                log_msg(logFile, f"Файл '{xml_to_close.path}' видалено зі списку відкритих.")

            # --- Початок змін: Запобігання діалогам збереження при закритті ---
            # Перед видаленням групи шарів, ми проходимо по кожному шару в ній
            # і примусово відкидаємо будь-які зміни в буфері редагування.
            # Це повідомляє QGIS, що для цих шарів не потрібно показувати діалог збереження.
            layers_root = QgsProject.instance().layerTreeRoot()
            group_to_process = layers_root.findGroup(xml_to_close.group_name)
            if group_to_process:
                for child_node in group_to_process.children():
                    if isinstance(child_node, QgsLayerTreeLayer):
                        child_node.layer().rollBack()
            # --- Кінець змін ---

            # 3. Видаляємо групу шарів з дерева QGIS.
            if not group_already_removed:
                group_to_remove = layers_root.findGroup(xml_to_close.group_name)
                if group_to_remove:
                    layers_root.removeChildNode(group_to_remove)
                    log_msg(logFile, f"Групу '{xml_to_close.group_name}' та її шари видалено.")

            # 4. Видаляємо вкладку з інтерфейсу.
            if tab_index_to_remove != -1:
                self.tabWidget.removeTab(tab_index_to_remove)
                log_msg(logFile, f"Вкладку для групи '{xml_to_close.group_name}' видалено.")
            # --- Кінець змін ---

            if not self.opened_xmls:
                self.current_xml = None
                self.update_window_title("")
                self.update_all_actions_state(is_file_open=False)
                # --- Початок змін: Приховування віджета, якщо не залишилось вкладок ---
                if self.tabWidget.count() == 0:
                    self.hide()
                    log_msg(logFile, "Останню вкладку закрито. Віджет приховано.")
                # --- Кінець змін ---
    
        finally:
            self._is_closing = False

    def get_tooltip_from_tree(self, full_path, default_name):
        """
        Отримує tooltip для елемента з дерева за його шляхом.
        Якщо tooltip не знайдено, повертає default_name.
        """
        # log_msg(logFile)  # recursion
        current_tab_widget = self.tabWidget.currentWidget()
        if current_tab_widget:
            tree_view = current_tab_widget.findChild(CustomTreeView)
            if tree_view:
                return tree_view.get_tooltip_from_tree(full_path, default_name)
        return default_name # Fallback


    def find_element_index(self, path=None, element_name=None):
        """
        Знаходить індекс елемента у дереві на основі шляху або імені.
        """
        # log_msg(logFile) # recursion
        current_tab_widget = self.tabWidget.currentWidget()
        if current_tab_widget:
            tree_view = current_tab_widget.findChild(CustomTreeView)
            if tree_view:
                return tree_view.find_element_index(path, element_name)
        return QModelIndex() # Fallback


    def handle_error_and_close(self, error_message):
        """
            Обробляє помилку, відображає повідомлення і закриває док-віджет.

            Аргументи:
                Текст повідомлення про помилку.
        """
        log_msg(logFile)

        self.parent.iface.messageBar().pushCritical("Помилка", error_message)
        self.close()



    def showEvent(self, event):
        """ 
            Відновлення вкладок при відкритті вікна 

        """
        # Обробка події показу віджета.
        # Подія виникає, перед тим як віджет стає видимим.

        # log_calls(logFile, f"event = {event}")

        super().showEvent(event)


    def close_tab(self, index):
        """
        Handle tab close events.
        """
        xml_data = self.get_xml_data_for_tab_index(index)
        if xml_data:
            self.process_action_close_xml(xml_to_close=xml_data)

    def on_custom_tab_save_button_clicked(self, index):
        """
        Обробляє клік на кастомній кнопці збереження на вкладці.
        Зберігає зміни для відповідного XML-файлу.
        """
        xml_to_save = self.get_xml_data_for_tab_index(index)
        if xml_to_save:
            self.save_specific_xml(xml_to_save)

    def setup_custom_tab_buttons(self):
        """
        Налаштовує кастомні кнопки закриття для всіх динамічних вкладок.
        """
        tab_bar = self.tabWidget.tabBar()

        for i in range(self.tabWidget.count()):
            # Перевіряємо, чи кнопка вже існує, щоб уникнути дублювання
            if tab_bar.tabButton(i, QTabBar.RightSide) is None:
                # Створюємо контейнер для кнопок
                buttons_widget = QWidget()
                buttons_layout = QHBoxLayout(buttons_widget)
                # Відступи: зліва 8px, справа 6px для симетрії та простору
                # 1) назва вкладки - іконка збереження
                # 2) top margin
                # 3) кнопка закриття - край вкладки
                # 4) bottom margin
                buttons_layout.setContentsMargins(0, 0, 0, 0)
                # відступ між кнопками
                buttons_layout.setSpacing(0)
                # Ключова зміна: змушує компонування резервувати місце для всіх віджетів
                buttons_layout.setSizeConstraint(QLayout.SetFixedSize)

                # Створюємо кнопку-індикатор збереження
                save_button = QPushButton(self.save_icon, "")
                save_button.setFlat(True)
                save_button.setFixedSize(16, 16)
                save_button.setIconSize(QSize(12, 12))
                save_button.setToolTip("Файл має незбережені зміни")
                save_button.setEnabled(False) # Спочатку неактивна
                save_button.setStyleSheet("""
                    QPushButton {
                        border: none; background: transparent; padding: 0px;
                    }
                """)
                self.tab_save_buttons[i] = save_button # Зберігаємо посилання

                # Створюємо кнопку закриття
                close_icon = self.style().standardIcon(QStyle.SP_DockWidgetCloseButton)
                close_button = QPushButton(close_icon, "")
                close_button.setFlat(True)
                close_button.setCursor(Qt.ArrowCursor)
                close_button.setFixedSize(16, 16)
                close_button.setIconSize(QSize(12, 12))
                close_button.setStyleSheet("""
                    QPushButton {
                        border: none; background: transparent; padding: 0px; margin-left: 0px;
                    }
                    QPushButton:hover {
                        background-color: #e0e0e0; border-radius: 2px;
                    }
                    QPushButton:pressed {
                        background-color: #a9a9a9;
                    }
                """)
                # Підключаємо сигнали з передачею індексу для надійності
                save_button.clicked.connect(lambda _, index=i: self.on_custom_tab_save_button_clicked(index))
                close_button.clicked.connect(lambda _, index=i: self.close_tab(index))

                buttons_layout.addWidget(save_button)
                buttons_layout.addWidget(close_button)
                buttons_widget.setLayout(buttons_layout)

                tab_bar.setTabButton(i, QTabBar.RightSide, buttons_widget)


    def on_layer_will_be_removed(self, layer_id):
        """
        Обробляє видалення шару з проекту.

        - Якщо видаляється останній шар у групі, закриває відповідну вкладку.
        - Якщо видаляється один з дозволених шарів ("Угіддя", "Оренда" тощо),
          видаляє відповідний розділ з XML-дерева.
        - Ігнорує видалення захищених шарів ("Ділянка", "Вузли" тощо).
        """
        LAYER_TO_XML_PATH = {
            # --- Початок змін: Уточнення XPath для надійності ---
            "Суміжники": ".//ParcelInfo/AdjacentUnits",
            "Обмеження": ".//ParcelInfo/Restrictions",
            "Суборенда": ".//ParcelInfo/Subleases",
            "Оренда": ".//ParcelInfo/Leases",
            "Угіддя": ".//ParcelInfo/LandsParcel"
        }
        # --- Кінець змін ---
        PROTECTED_LAYERS = ["Ділянка", "Кадастровий квартал", "Кадастрова зона", "Полілінії", "Вузли"]

        layer = QgsProject.instance().mapLayer(layer_id)
        if not layer:
            return

        layer_name = layer.name()
        log_msg(logFile, f"Видалення '{layer_name}': {str(layer_id)}.")

        xml_data = self.find_xml_data_for_layer(layer)
        if not xml_data:
            log_msg(logFile, f"Не знайдено відповідний XML-файл для шару '{layer_name}'. Обробку зупинено.")
            return

        # Логіка видалення відповідного XML-вузла
        if layer_name in LAYER_TO_XML_PATH:
            xml_path = LAYER_TO_XML_PATH[layer_name]
            xml_element = xml_data.tree.getroot().find(xml_path)

            # if xml_element is not None:
            #     # --- Початок змін: Запобігання видаленню розділу суміжників ---
            #     # Якщо видаляється шар "Суміжники", ми не показуємо діалог і не видаляємо
            #     # відповідний розділ з XML, ніби користувач завжди відповідає "Ні".
            #     if layer_name == "Суміжники":
            #         log_msg(logFile, f"Видалення розділу '{xml_element.tag}' з XML для шару '{layer_name}' було заблоковано.")
            #     else:
            #         reply = QMessageBox.question(
            #             self,
            #             "Підтвердження видалення",
            #             f"Ви видаляєте шар '{layer_name}'.\n\n"
            #             f"Це також призведе до видалення відповідного розділу '{xml_element.tag}' з XML-файлу '{os.path.basename(xml_data.path)}'.\n\n"
            #             "Ви впевнені, що хочете продовжити?",
            #             QMessageBox.Yes | QMessageBox.No,
            #             QMessageBox.No
            #         )
            # 
            #         if reply == QMessageBox.Yes:
            #             xml_element.getparent().remove(xml_element)
            #             log_msg(logFile, f"Вузол '{xml_path}' видалено з XML-дерева за згодою користувача.")
            #             xml_data.tree_view.rebuild_tree_view()
            #             self.mark_as_changed()
            #     # --- Кінець змін ---
            # else:
            #     log_msg(logFile, f"Помилка: не вдалося знайти вузол '{xml_path}' в XML-дереві для видалення.")
            # return # Зупиняємо подальшу обробку, щоб не закрити всю групу
            pass
        else:
            log_msg(logFile, f"Шар '{layer_name}' не підлягає синхронізації видалення з XML.")

        # Логіка закриття вкладки при видаленні останнього шару
        root = QgsProject.instance().layerTreeRoot()
        node = root.findLayer(layer.id())
        parent_group = node.parent() if node else None

        if parent_group and isinstance(parent_group, QgsLayerTreeGroup):
            if len(parent_group.children()) == 1:
                log_msg(logFile, f"Видалено останній шар з групи '{parent_group.name()}'. Закриваємо відповідну вкладку.")
                self.process_action_close_xml(xml_data, group_already_removed=True)


    def on_tab_changed(self, index):
        """Синхронізує активну вкладку з деревом шарів."""
        # if index != -1:
        #     QMessageBox.information(
        #         self.iface.mainWindow(),
        #         "Сигнал: on_tab_changed",
        #         f"Переключено на вкладку: '{self.tabWidget.tabText(index)}' (індекс: {index})"
        #     )
        if index == -1: # Немає активних вкладок
            self.current_xml = None
            self.update_all_actions_state(is_file_open=False)
            return

        # --- Початок змін: Гарантоване відображення кнопок на вкладках ---
        # Перевіряємо та за потреби додаємо кнопки при кожному перемиканні вкладки.
        self.setup_custom_tab_buttons()
        # --- Кінець змін ---
        xml_data = self.get_xml_data_for_tab_index(index)
        if xml_data:
            self.current_xml = xml_data
            self.update_all_actions_state(is_file_open=True)
            self.update_changed_actions_state(is_changed=xml_data.changed)
            layers_root = QgsProject.instance().layerTreeRoot()
            group = layers_root.findGroup(xml_data.group_name)
            if group:
                self.iface.layerTreeView().setCurrentNode(group)

    def update_changed_actions_state(self, is_changed):
        """Оновлює стан дій, які залежать від наявності змін."""
        if self.plugin:
            self.plugin.action_save_tool.setEnabled(is_changed)
            self.plugin.action_restore_backup.setEnabled(is_changed)

    def update_all_actions_state(self, is_file_open):
        """Оновлює стан дій, які залежать від того, чи відкритий файл."""
        if self.plugin:
            self.plugin.action_save_as_template_tool.setEnabled(is_file_open)
            self.plugin.action_check_tool.setEnabled(is_file_open)
            self.plugin.action_clear_data.setEnabled(is_file_open)
            if not is_file_open:
                self.update_changed_actions_state(False)

    def update_tab_indices(self):
        """ 
        Оновлює індекси вкладок після закриття.
        """
        # Ця логіка більше не потрібна, оскільки кнопки закриття стандартні

    def generate_layers_obj_name(self, base_name):
        """
        Формує назву групи на основі базової назви, додаючи суфікс, якщо група з такою назвою вже існує.

        Args:
            base_name (str): Базова назва групи (назва файлу без розширення).

        Returns:
            str: Назва групи.
        """
        layers_root = QgsProject.instance().layerTreeRoot()
        layers_obj_name = base_name
        suffix = 0

        while layers_root.findGroup(layers_obj_name):
            suffix += 1
            layers_obj_name = f"{base_name}#{suffix}"

        return layers_obj_name


    def double_clicked(self, index):
        """
        Обробляє подвійне клацання на елементі в дереві шарів.
        """
        log_msg(logFile)

        # Отримуємо QgsLayerTreeNode, використовуючи QgsLayerTreeView
        item = self.iface.layerTreeView().index2node(index)

        if item is None:
            log_msg(logFile, f"item is None")
            return

        # log_msg(logFile, f"item.name() = {item.name()}")

        if isinstance(item, QgsLayerTreeGroup):
            layers_obj_name = item.name()
            log_msg(
                logFile, f"layers_obj_name = {layers_obj_name}")


    def clicked(self, index):
        """
        Обробляє  клацання на елементі в дереві шарів.
        """
        # (logFile, f"index = {index}")

        # QMessageBox.information(
        #     self.iface.mainWindow(),
        #     "Сигнал: clicked",
        #     f"Клік на елементі дерева шарів."
        # )
        # Отримуємо QgsLayerTreeNode, використовуючи QgsLayerTreeView
        item = self.iface.layerTreeView().index2node(index)

        if item is None:
            log_msg(logFile, f"item is None")
            return

        if isinstance(item, QgsLayerTreeGroup):
            self.process_group_click(item.name())

        # Якщо елемент не група, то обробляємо його, то 
        # знаходимо його групу:
        if isinstance(item, QgsLayerTreeLayer):
            # log_msg(logFile, f"Клік на шарі {item.name()}")
            # Отримуємо групу шару
            group = self.find_parent_group(item) # type: ignore
            if group:
                group_name = group.name()
                # log_msg(logFile, f"Шар '{item.name()}' знаходиться в групі '{group_name}'")
                self.process_group_click(group_name)
            else:
                # log_msg(logFile, f"Шар '{item.name()}' не належить до жодної групи")
                pass

    def find_parent_group(self, item: QgsLayerTreeLayer) -> QgsLayerTreeGroup:
        """
        Finds the parent group of a given QgsLayerTreeLayer item.

        This method traverses the parent hierarchy of the provided QgsLayerTreeLayer
        to locate and return the first QgsLayerTreeGroup it belongs to. If no parent
        group is found, the method returns None.

        Args:
            item (QgsLayerTreeLayer): The layer tree item for which the parent group
                                      is to be found.

        Returns:
            QgsLayerTreeGroup: The parent group of the given item, or None if no
                               parent group exists.
        """
        if item is None:
            return None

        parent = item.parent()
        while parent:
            if isinstance(parent, QgsLayerTreeGroup):
                return parent
            parent = parent.parent()
        return None

    def get_xml_data_for_tab_index(self, index):
        """Повертає об'єкт xml_data для вкладки за її індексом."""
        if index < 0 or index >= self.tabWidget.count():
            return None
        
        tab_name = self.tabWidget.tabText(index)
        # Ми припускаємо, що назва вкладки - це group_name
        for xml_data in self.opened_xmls:
            if xml_data.group_name == tab_name:
                return xml_data
        return None

    def validate_xml_structure(self, xml_path):

        #✔️ 2025.04.03 08:59
        # Перевіряти треба xml при відкритті і шаблони при створенні, бо
        # користувач може зробити помилку у шаблоні 
        # Це часткова перевірка структури XML
        # Повна перевірка структури XML засобами library lxml
        # не працює, бо ВСІ файли не відповідають схемі XSD
        # у майбутньому треба розширити перевірку
        # з врахуванням того, що файл може бути у процесі розробки

        #✔️ 2025.04.03  
        # log_msg(logFile)

        # Список обов'язкових елементів
        mandatory_elements = [
            "AdditionalPart",
            "ServiceInfo",
            "FileID",
            "FormatVersion",
            "FileDate",
            "FileGUID",
            "ReceiverName",
            "ReceiverIdentifier",
            "Software",
            "SoftwareVersion",
            "InfoLandWork",
            "Executor",
            "CompanyName",
            "Chief",
            "Address",
            "InfoPart",
            "MetricInfo",
            "CoordinateSystem",
            "HeightSystem",
            "MeasurementUnit",
            "PointInfo",
            "Polyline",
            "ControlPoint",
            "CadastralZoneInfo",
            "CadastralZoneNumber",
            "CadastralQuarterInfo",
            "CadastralQuarterNumber",
            "ParcelInfo",
            "ParcelMetricInfo"
        ]
        try:
            # 1. Parse the XML (Well-Formedness Check)
            tree = etree.parse(xml_path)
            root = tree.getroot()

            # 2. Check for a Root Element
            if root is None:
                log_msg(logFile, "Error: No root element found in the XML file.")
                return False

            # Check if the root element's tag is 'UkrainianCadastralExchangeFile'
            if root.tag != "UkrainianCadastralExchangeFile":
                log_msg(
                    logFile, f"Error: Root element is '{root.tag}', expected 'UkrainianCadastralExchangeFile'.")
                return False

            for element_name in mandatory_elements:
                element = root.find(".//" + element_name)
                if element is None:
                    log_msg(
                        logFile, f"Error: Mandatory element '{element_name}' is missing.")
                    return False
        except Exception as e:
            log_msg(logFile, f"Error during XML structure validation: {e}")
            return False

        return True

    def save_specific_xml(self, xml_to_save):
        """Зберігає конкретний XML-файл без додаткових діалогів."""
        if not xml_to_save:
            return

        try:
            # --- Початок змін: Збереження в обидва файли ---
            # 1. Зберігаємо у файл, що редагується (з часовою міткою)
            xml_to_save.tree_view.save_xml_tree(xml_to_save.tree, xml_to_save.path)
            log_msg(logFile, f"Файл, що редагується, збережено: {xml_to_save.path}")

            # 2. Зберігаємо в оригінальний файл (без часової мітки)
            if xml_to_save.original_path and xml_to_save.original_path != xml_to_save.path:
                xml_to_save.tree_view.save_xml_tree(xml_to_save.tree, xml_to_save.original_path)
                log_msg(logFile, f"Оригінальний файл оновлено: {xml_to_save.original_path}")
                self.iface.messageBar().pushMessage("Диск:", f"Файли '{os.path.basename(xml_to_save.original_path)}' та '{os.path.basename(xml_to_save.path)}' збережено.", level=Qgis.Success, duration=5)
            else:
                self.iface.messageBar().pushMessage("Диск:", f"Файл збережено: {xml_to_save.path}", level=Qgis.Success, duration=5)
            # --- Кінець змін ---

            # Позначаємо, що зміни збережено
            xml_to_save.changed = False
            # Оновлюємо іконку вкладки та стан кнопок
            if self.update_tab_style_by_group_name(xml_to_save.group_name, is_changed=False):
                if xml_to_save == self.current_xml:
                    self.update_changed_actions_state(is_changed=False)
            self.update_window_title(xml_to_save.path)
        except Exception as e:
            log_msg(logFile, f"Помилка при збереженні файлу '{xml_to_save.path}': {e}")
            QMessageBox.critical(self, "Помилка збереження", f"Не вдалося зберегти файл:\n{e}")


    def process_group_click(self, group_name):
        """
        Handles the event when a group in the QGIS layer tree is clicked.

        This method synchronizes the dock widget with the selected group in the 
        QGIS layer tree. It ensures that the corresponding XML data for the group 
        is loaded and displayed in the dock widget.

        Args:
            group_name (str): The name of the group clicked in the QGIS layer tree.

        Behavior:
            - Logs the group click event.
            - Checks if the 'opened_xmls' attribute is initialized. If not, displays 
              a warning message and logs an error.
            - Searches for the clicked group in the QGIS layer tree. If not found, 
              logs an error and exits.
            - Searches for the corresponding XML data in the 'opened_xmls' list. If 
              not found, logs a message and exits.
            - If the dock widget is hidden, it is shown.
            - Clears the dock widget's data and loads the XML data associated with 
              the clicked group.
            - Configures the appearance of the XML tree view in the dock widget.
            - Updates the dock widget's title to reflect the current XML file path.

        Raises:
            None
        """


        # Основна мета — синхронізувати доквіджет з вибраною групою 
        # в дереві шарів QGIS коли користувач клацає групу, 

        # log_msg(logFile, group_name)
        logFile.flush()

        # Знаходимо відповідну вкладку
        for i in range(self.tabWidget.count()):
            if self.tabWidget.tabText(i) == group_name:
                # Переключаємось на вкладку, це викличе on_tab_changed, який оновить self.current_xml
                if self.tabWidget.currentIndex() != i:
                    self.tabWidget.setCurrentIndex(i)
                else: # Якщо вкладка вже активна, просто оновлюємо дані
                    self.current_xml = self.get_xml_data_for_tab_index(i)
                    self.update_window_title(self.current_xml.path)
                break


    def update_xml_from_geometry_change(self, layer, feature_id):
        """
        Оновлює XML-дерево, коли геометрія точки змінюється в QGIS.
        """
        log_msg(logFile, f"Оновлення XML для шару: {layer.name()}, ID фічі: {feature_id}")

        # 1. Визначаємо, з яким XML-файлом ми працюємо
        xml_data = self.find_xml_data_for_layer(layer)
        if not xml_data:
            log_msg(logFile, f"Не знайдено відповідний XML для шару '{layer.name()}'.")
            return

        # 2. Перевіряємо, чи це шар точок
        if layer.name() != "Вузли":
            log_msg(logFile, f"Шар '{layer.name()}' не є шаром пікетів. Оновлення геометрії ігнорується.")
            return

        # 3. Отримуємо фічу та її нову геометрію
        feature = layer.getFeature(feature_id)
        if not feature:
            log_msg(logFile, f"Фіча з ID {feature_id} не знайдена в шарі {layer.name()}.")
            return
        new_geometry = feature.geometry()
        point_geom = new_geometry.asPoint()
        uidp = feature.attribute("UIDP")

        if not uidp:
            log_msg(logFile, f"Фіча з ID {feature_id} не має атрибута 'UIDP'.")
            return

        # 4. Оновлюємо XML-дерево
        tree = xml_data.tree
        point_element = tree.find(f".//PointInfo/Point[UIDP='{uidp}']")

        if point_element is None:
            log_msg(logFile, f"Точка з UIDP '{uidp}' не знайдена в XML.")
            return

        # Оновлюємо координати (пам'ятаємо про заміну X та Y)
        point_element.find("X").text = f"{point_geom.y():.3f}"
        point_element.find("Y").text = f"{point_geom.x():.3f}"
        log_msg(logFile, f"Оновлено координати для точки UIDP='{uidp}' в XML.")

        # 5. Перераховуємо довжини ліній, що використовують цю точку
        self.recalculate_line_lengths(tree, uidp)

        # 5.1 Перераховуємо площу ділянки
        self.recalculate_parcel_area(tree)

        # 6. Оновлюємо вигляд дерева у вкладці
        xml_data.tree_view.update_view_from_tree()

        # 7. Позначаємо вкладку як змінену
        xml_data.tree_view.mark_as_changed()

        # НЕ зберігаємо на диск і НЕ перемальовуємо шари тут, щоб уникнути краху.
        # Зберігаємо тимчасову копію дерева для можливого відкату.
        if not hasattr(xml_data, 'temp_tree_state') or xml_data.temp_tree_state is None:
             # Повідомлення для користувача
             self.iface.messageBar().pushMessage(
                "Інформація", f"Вузол '{uidp}' було переміщено. Збережіть зміни, щоб оновити XML та шари.",
                level=Qgis.Info, duration=5
             )
             # Створюємо копію тільки якщо її ще немає, щоб зберегти стан *до* першої зміни
             original_tree = etree.parse(xml_data.path)
             xml_data.temp_tree_state = original_tree

    def add_lands(self):
        """
        Додає угіддя з виділеного полігону до активного XML-файлу.
        """
        log_msg(logFile, "Спроба додати угіддя до активного XML.")

        if not self.current_xml:
            QMessageBox.warning(self, "Помилка", "Немає активного XML-файлу для додавання угідь.")
            return

        # 1. Отримати виділений полігон
        selected_features = []
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.type() == layer.VectorLayer:
                selected_features.extend(layer.selectedFeatures())

        if len(selected_features) != 1:
            QMessageBox.warning(self, "Помилка", "Будь ласка, виберіть рівно один полігональний об'єкт.")
            return

        feature = selected_features[0]
        geom = feature.geometry()
        if geom.wkbType() not in [QgsWkbTypes.Polygon, QgsWkbTypes.MultiPolygon]:
            QMessageBox.warning(self, "Помилка", "Вибраний об'єкт не є полігоном.")
            return

        # --- Початок змін: Обробка геометрії через GeometryProcessor для отримання object_shape ---
        tree = self.current_xml.tree
        processor = GeometryProcessor(tree)
        externals_element, new_points, new_polylines, object_shape = processor.process_new_geometry(geom)
        log_msg(logFile, f"Додавання угіддя: геометрія виділеного полігону (object_shape): '{object_shape}'")
        # 2. Знайти або створити шар "Угіддя"
        layers_root = QgsProject.instance().layerTreeRoot()
        group = layers_root.findGroup(self.current_xml.group_name)
        if not group:
            log_msg(logFile, f"Група '{self.current_xml.group_name}' не знайдена.")
            return

        layer_name = "Угіддя"
        lands_layer = None
        for child in group.children():
            if isinstance(child, QgsLayerTreeLayer) and child.name() == layer_name:
                lands_layer = child.layer()
                break

        if lands_layer is None:
            # Створюємо шар, якщо його немає
            lands_layer = QgsVectorLayer(f"MultiPolygon?crs={self.iface.mapCanvas().mapSettings().destinationCrs().authid()}", layer_name, "memory")
            lands_layer.loadNamedStyle(os.path.join(os.path.dirname(__file__), "templates", "lands_parcel.qml"))
            provider = lands_layer.dataProvider()
            provider.addAttributes([
                QgsField("LandCode", QVariant.String),
                QgsField("Size", QVariant.Double),
            ])
            lands_layer.updateFields()
            QgsProject.instance().addMapLayer(lands_layer, False)
            group.insertChildNode(0, QgsLayerTreeLayer(lands_layer))
            log_msg(logFile, f"Створено новий шар '{layer_name}' у групі '{group.name()}'.")

        # 3. Додати новий об'єкт до шару
        new_feature = QgsFeature(lands_layer.fields())
        new_feature.setGeometry(geom)
        
        # Запитуємо у користувача код угіддя
        land_code_delegate = self.current_xml.tree_view.land_code_delegate
        land_code_items = land_code_delegate.items
        
        land_code_selection, ok = QInputDialog.getItem(self, "Вибір коду угіддя",
                                                     "Виберіть код угіддя:", land_code_items, 0, False)
        
        if not ok or not land_code_selection:
            log_msg(logFile, "Додавання угіддя скасовано користувачем.")
            return

        land_code = land_code_delegate.reverse_land_codes.get(land_code_selection)
        if not land_code:
            log_msg(logFile, f"Не вдалося отримати код для '{land_code_selection}'.")
            return

        size_ha = geom.area() / 10000.0
        new_feature.setAttributes([land_code, size_ha])
        
        lands_layer.startEditing()
        lands_layer.addFeature(new_feature)
        lands_layer.commitChanges()
        # --- Кінець змін ---
        # 4. Додати відповідні елементи до XML-дерева (використовуємо вже отримані externals_element)
        root = tree.getroot()
        parcel_info_element = root.find(".//ParcelInfo")
        if parcel_info_element is None:
            log_msg(logFile, "Елемент 'ParcelInfo' не знайдено в XML.")
            return

        lands_parcel_element = parcel_info_element.find("LandsParcel")
        if lands_parcel_element is None:
            lands_parcel_element = etree.SubElement(parcel_info_element, "LandsParcel")

        land_parcel_info = etree.SubElement(lands_parcel_element, "LandParcelInfo")
        etree.SubElement(land_parcel_info, "LandCode").text = land_code
        metric_info = etree.SubElement(land_parcel_info, "MetricInfo")
        area = etree.SubElement(metric_info, "Area")
        etree.SubElement(area, "Size").text = f"{size_ha:.4f}"
        etree.SubElement(area, "MeasurementUnit").text = "га"

        # Перевіряємо, чи повернулися дані, перш ніж розпаковувати.
        # processed_data може бути None, якщо геометрія некоректна.
        if externals_element is not None:
            if externals_element is not None:
                metric_info.append(externals_element) # type: ignore
            log_msg(logFile, f"Додавання: шар 'Угіддя', джерело 'геометричний об''єкт', object_shape: '{object_shape}'") # type: ignore

        # 5. Оновити вигляд дерева та позначити зміни
        self.current_xml.tree_view.rebuild_tree_view()
        self.current_xml.tree_view.mark_as_changed()

        # --- Початок змін: Переміщення перемалювання шару ---
        # Перемальовуємо шар, щоб відобразити новий об'єкт
        self.redraw_specific_layer(self.current_xml, "Угіддя")
        # --- Кінець змін ---
        # НЕ зберігаємо на диск і НЕ перемальовуємо шари тут, щоб уникнути краху.
        # Зберігаємо тимчасову копію дерева для можливого відкату.
        if not hasattr(self.current_xml, 'temp_tree_state') or self.current_xml.temp_tree_state is None:
             # Повідомлення для користувача
             self.iface.messageBar().pushMessage(
                "Інформація", f"Угіддя з кодом '{land_code}' було додано. Збережіть зміни, щоб оновити XML та шари.",
                level=Qgis.Info, duration=5
             )
             # Створюємо копію тільки якщо її ще немає, щоб зберегти стан *до* першої зміни
             original_tree = etree.parse(self.current_xml.path)
             self.current_xml.temp_tree_state = original_tree

    def add_lease(self):
        """
        Додає оренду з виділеного полігону до активного XML-файлу.
        """
        log_msg(logFile, "Спроба додати оренду до активного XML.")

        if not self.current_xml:
            QMessageBox.warning(self, "Помилка", "Немає активного XML-файлу для додавання оренди.")
            return

        # 1. Отримати виділений полігон
        selected_features = []
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.type() == layer.VectorLayer:
                selected_features.extend(layer.selectedFeatures())

        if len(selected_features) != 1:
            QMessageBox.warning(self, "Помилка", "Будь ласка, виберіть рівно один полігональний об'єкт.")
            return

        feature = selected_features[0]
        geom = feature.geometry()
        if geom.wkbType() not in [QgsWkbTypes.Polygon, QgsWkbTypes.MultiPolygon]:
            QMessageBox.warning(self, "Помилка", "Вибраний об'єкт не є полігоном.")
            return

        # 2. Обробити геометрію та оновити XML
        tree = self.current_xml.tree
        processor = GeometryProcessor(tree)
        
        try:
            # Викликаємо новий метод для обробки геометрії оренди
            processor.process_lease_geometry(geom)
            log_msg(logFile, "Геометрію для нової оренди оброблено та додано до XML.")
        except Exception as e:
            log_msg(logFile, f"Помилка при обробці геометрії оренди: {e}")
            QMessageBox.critical(self, "Помилка", f"Не вдалося додати оренду: {e}")
            return

        # 3. Оновити вигляд дерева та позначити зміни
        self.current_xml.tree_view.rebuild_tree_view()
        self.mark_as_changed()

        # 4. Створити або оновити шар "Оренда"
        layers_root = QgsProject.instance().layerTreeRoot()
        group = layers_root.findGroup(self.current_xml.group_name)
        if not group:
            log_msg(logFile, f"Група '{self.current_xml.group_name}' не знайдена для додавання шару оренди.")
            return

        layer_name = "Оренда"
        leases_layer = next((child.layer() for child in group.children() if isinstance(child, QgsLayerTreeLayer) and child.name() == layer_name), None)

        from .leases import Leases
        leases_handler = Leases(
            root=self.current_xml.tree.getroot(),
            crs_epsg=self.iface.mapCanvas().mapSettings().destinationCrs().authid(),
            group=group,
            plugin_dir=self.plugin.plugin_dir,
            lines_to_coords_func=self.layers_obj.linesToCoordinates,
            xml_ua_layers_instance=self.layers_obj
        )

        if leases_layer is None:
            log_msg(logFile, f"Шар '{layer_name}' не знайдено. Створюємо новий.")
            leases_layer = leases_handler.add_leases_layer()
            if not leases_layer:
                log_msg(logFile, f"Не вдалося створити шар '{layer_name}'.")
                return
        else:
            log_msg(logFile, f"Шар '{layer_name}' знайдено. Оновлюємо його.")
            # Перемальовуємо шар, щоб додати новий об'єкт
            leases_handler.redraw_leases_layer(leases_layer)

        self.iface.messageBar().pushMessage("Успіх", f"Оренду додано до групи '{self.current_xml.group_name}'.", level=Qgis.Success, duration=5)
        log_msg(logFile, f"Оренду додано до XML для групи '{self.current_xml.group_name}'.")

    def add_sublease(self):
        """
        Додає суборенду з виділеного полігону до активного XML-файлу.
        """
        log_msg(logFile, "Спроба додати суборенду до активного XML.")

        if not self.current_xml:
            QMessageBox.warning(self, "Помилка", "Немає активного XML-файлу для додавання суборенди.")
            return

        # 1. Отримати виділений полігон
        selected_features = []
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.type() == layer.VectorLayer:
                selected_features.extend(layer.selectedFeatures())

        if len(selected_features) != 1:
            QMessageBox.warning(self, "Помилка", "Будь ласка, виберіть рівно один полігональний об'єкт.")
            return

        feature = selected_features[0]
        geom = feature.geometry()
        if geom.wkbType() not in [QgsWkbTypes.Polygon, QgsWkbTypes.MultiPolygon]:
            QMessageBox.warning(self, "Помилка", "Вибраний об'єкт не є полігоном.")
            return

        # 2. Обробити геометрію та оновити XML
        tree = self.current_xml.tree
        processor = GeometryProcessor(tree)
        
        try:
            # Викликаємо новий метод для обробки геометрії суборенди
            processor.process_sublease_geometry(geom)
            log_msg(logFile, "Геометрію для нової суборенди оброблено та додано до XML.")
        except Exception as e:
            log_msg(logFile, f"Помилка при обробці геометрії суборенди: {e}")
            QMessageBox.critical(self, "Помилка", f"Не вдалося додати суборенду: {e}")
            return

        # 3. Оновити вигляд дерева та позначити зміни
        self.current_xml.tree_view.rebuild_tree_view()
        self.mark_as_changed()

        # 4. Створити або оновити шар "Суборенда"
        layers_root = QgsProject.instance().layerTreeRoot()
        group = layers_root.findGroup(self.current_xml.group_name)
        if not group:
            log_msg(logFile, f"Група '{self.current_xml.group_name}' не знайдена для додавання шару суборенди.")
            return

        layer_name = "Суборенда"
        subleases_layer = next((child.layer() for child in group.children() if isinstance(child, QgsLayerTreeLayer) and child.name() == layer_name), None)

        from .subleases import Subleases
        subleases_handler = Subleases(
            root=self.current_xml.tree.getroot(),
            crs_epsg=self.iface.mapCanvas().mapSettings().destinationCrs().authid(),
            group=group,
            plugin_dir=self.plugin.plugin_dir,
            lines_to_coords_func=self.layers_obj.linesToCoordinates,
            xml_ua_layers_instance=self.layers_obj
        )

        if subleases_layer is None:
            log_msg(logFile, f"Шар '{layer_name}' не знайдено. Створюємо новий.")
            subleases_layer = subleases_handler.add_subleases_layer()
            if not subleases_layer:
                log_msg(logFile, f"Не вдалося створити шар '{layer_name}'.")
                return
        else:
            log_msg(logFile, f"Шар '{layer_name}' знайдено. Оновлюємо його.")
            # Перемальовуємо шар, щоб додати новий об'єкт
            subleases_handler.redraw_subleases_layer(subleases_layer)

        self.iface.messageBar().pushMessage("Успіх", f"Суборенду додано до групи '{self.current_xml.group_name}'.", level=Qgis.Success, duration=5)
        log_msg(logFile, f"Суборенду додано до XML для групи '{self.current_xml.group_name}'.")

    def add_restriction(self):
        """
        Додає обмеження з виділеного полігону до активного XML-файлу.
        """
        log_msg(logFile, "Спроба додати обмеження до активного XML.")

        if not self.current_xml:
            QMessageBox.warning(self, "Помилка", "Немає активного XML-файлу для додавання обмеження.")
            return

        # 1. Отримати виділений полігон
        selected_features = []
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.type() == layer.VectorLayer:
                selected_features.extend(layer.selectedFeatures())

        if len(selected_features) != 1:
            QMessageBox.warning(self, "Помилка", "Будь ласка, виберіть рівно один полігональний об'єкт.")
            return

        feature = selected_features[0]
        geom = feature.geometry()
        if geom.wkbType() not in [QgsWkbTypes.Polygon, QgsWkbTypes.MultiPolygon]:
            QMessageBox.warning(self, "Помилка", "Вибраний об'єкт не є полігоном.")
            return

        # 2. Обробити геометрію та оновити XML
        tree = self.current_xml.tree
        processor = GeometryProcessor(tree)
        
        try:
            # Викликаємо новий метод для обробки геометрії обмеження
            processor.process_restriction_geometry(geom)
            log_msg(logFile, "Геометрію для нового обмеження оброблено та додано до XML.")
        except Exception as e:
            log_msg(logFile, f"Помилка при обробці геометрії обмеження: {e}")
            QMessageBox.critical(self, "Помилка", f"Не вдалося додати обмеження: {e}")
            return

        # 3. Оновити вигляд дерева та позначити зміни
        self.current_xml.tree_view.rebuild_tree_view()
        self.mark_as_changed()

        # 4. Створити або оновити шар "Обмеження"
        layers_root = QgsProject.instance().layerTreeRoot()
        group = layers_root.findGroup(self.current_xml.group_name)
        if not group:
            log_msg(logFile, f"Група '{self.current_xml.group_name}' не знайдена для додавання шару обмежень.")
            return

        layer_name = "Обмеження"
        restrictions_layer = next((child.layer() for child in group.children() if isinstance(child, QgsLayerTreeLayer) and child.name() == layer_name), None)

        from .restrictions import Restrictions
        restrictions_handler = Restrictions(
            root=self.current_xml.tree.getroot(),
            crs_epsg=self.iface.mapCanvas().mapSettings().destinationCrs().authid(),
            group=group,
            plugin_dir=self.plugin.plugin_dir,
            lines_to_coords_func=self.layers_obj.linesToCoordinates,
            xml_ua_layers_instance=self.layers_obj
        )

        if restrictions_layer is None:
            log_msg(logFile, f"Шар '{layer_name}' не знайдено. Створюємо новий.")
            restrictions_layer = restrictions_handler.add_restrictions_layer()
            if not restrictions_layer:
                log_msg(logFile, f"Не вдалося створити шар '{layer_name}'.")
                return
        else:
            log_msg(logFile, f"Шар '{layer_name}' знайдено. Оновлюємо його.")
            # Перемальовуємо шар, щоб додати новий об'єкт
            restrictions_handler.redraw_restrictions_layer(restrictions_layer)

        self.iface.messageBar().pushMessage("Успіх", f"Обмеження додано до групи '{self.current_xml.group_name}'.", level=Qgis.Success, duration=5)
        log_msg(logFile, f"Обмеження додано до XML для групи '{self.current_xml.group_name}'.")

    def add_adjacent_unit(self):
        """
        Додає нового суміжника на основі виділеного на карті полілінійного об'єкта.

        Цей метод є основним обробником для додавання суміжників. Він виконує
        повний цикл операцій: від отримання геометрії з карти до оновлення
        XML-даних та перемалювання відповідних шарів у QGIS.

        Логіка роботи:
        1.  **Перевірка умов**: Переконується, що є активний XML-файл та на карті
            виділено рівно один полілінійний об'єкт.
        2.  **Обробка геометрії**: Викликає `GeometryProcessor.process_adjacent_unit_geometry`,
            який аналізує геометрію виділеної лінії, унікалізує її вузли та сегменти
            (створюючи нові або використовуючи існуючі), та додає відповідні
            елементи `<PointInfo>`, `<Polyline>` та `<AdjacentUnitInfo>` до XML-дерева.
        3.  **Оновлення GUI**: Викликає `rebuild_tree_view()` для відображення нового
            суміжника у дереві XML та `mark_as_changed()` для позначення файлу як
            зміненого.
        4.  **Синхронізація та перемалювання шарів**:
            - Примусово оновлює посилання на XML-дерево в обробниках шарів
              (`points_handler`, `lines_handler`, `adjacents_handler`), щоб вони
              працювали з актуальними даними.
            - Викликає `redraw_pickets_layer()` та `redraw_lines_layer()` для
              оновлення шарів "Вузли" та "Полілінії", оскільки могли бути додані нові елементи.
            - Викликає `add_adjacents_layer()` для повного перемалювання шару "Суміжники".
        5.  **Створення точки відновлення**: Створює тимчасову копію стану XML-дерева
            для можливості відкату змін.
        """ # noqa
        log_msg(logFile, "Додавання суміжника до активного XML.")

        if not self.current_xml:
            QMessageBox.warning(self, "Помилка", "Немає активного XML-файлу для додавання суміжника.")
            return

        # 1. Отримати виділену полілінію
        selected_features = []
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.type() == layer.VectorLayer and layer.geometryType() == QgsWkbTypes.LineGeometry:
                selected_features.extend(layer.selectedFeatures())

        if len(selected_features) != 1:
            # QMessageBox.warning(self, "Помилка", "Будь ласка, виберіть рівно один полілінійний об'єкт.")
            return

        feature = selected_features[0]
        geom = feature.geometry()
        if geom.wkbType() not in [QgsWkbTypes.LineString, QgsWkbTypes.MultiLineString]:
            QMessageBox.warning(self, "Помилка додавання суміжника", "Вибраний об'єкт не є полілінією.")
            return

        # --- Початок змін: Формування object_shape для логування ---
        # Отримуємо точки з геометрії для створення "відбитка"
        polyline_points = geom.asPolyline()
        # Створюємо тимчасовий процесор, щоб отримати UIDP без зміни основного дерева
        temp_processor = GeometryProcessor(self.current_xml.tree)
        shape_uidps = []
        for i, p in enumerate(polyline_points):
            uidp = temp_processor._get_or_create_point(p)
            shape_uidps.append(uidp)
        object_shape = "-".join(shape_uidps)
        # --- Кінець змін ---

        # --- Початок змін: Логування стану дерева ---
        adj_units_before = self.current_xml.tree.find(".//AdjacentUnits")
        if adj_units_before is None:
            log_msg(logFile, "(до обробки): Розділ 'AdjacentUnits' ВІДСУТНІЙ.")
        else:
            count = len(adj_units_before.findall("AdjacentUnitInfo"))
            log_msg(logFile, f"(до обробки): Розділ 'AdjacentUnits' ІСНУЄ. Кількість суміжників: {count}.")
        # --- Кінець змін ---
        # 2. Обробити геометрію та оновити XML
        tree = self.current_xml.tree
        log_msg(logFile, f"Обробка геометрії. ID дерева XML до обробки: {id(tree)}")
        processor = GeometryProcessor(tree)

        try:
            # Викликаємо новий метод для обробки суміжника
            processor.process_adjacent_unit_geometry(geom)
            log_msg(logFile, f"Геометрію для суміжника {object_shape} оброблено та додано до XML.")
            log_msg(logFile, f"ID дерева XML після обробки: {id(self.current_xml.tree)}")
            # --- Початок змін: Логування стану дерева ---
            adj_units_after = self.current_xml.tree.find(".//AdjacentUnits")
            if adj_units_after is None:
                log_msg(logFile, "(після обробки): Розділ 'AdjacentUnits' ВІДСУТНІЙ.")
            else:
                count = len(adj_units_after.findall("AdjacentUnitInfo"))
                log_msg(logFile, f"(після обробки): Розділ 'AdjacentUnits' ІСНУЄ. Кількість суміжників: {count}.")
            # --- Кінець змін ---
        except Exception as e:
            # log_msg(logFile, f"Помилка при обробці геометрії суміжника: {e}")
            # QMessageBox.critical(self, "Помилка", f"Не вдалося додати суміжника: {e}")
            return

        log_msg(logFile, "Початок безпечного оновлення шарів.")
        if self.layers_obj:
            # --- Початок змін: Примусове оновлення XML-дерева в обробниках --- #
            # Перед перемалюванням шарів, ми оновлюємо посилання на XML-дерево #
            # у всіх обробниках, щоб вони використовували актуальну версію з новим суміжником. #
            updated_root = self.current_xml.tree.getroot()
            self.layers_obj.points_handler.root = updated_root
            self.layers_obj.lines_handler.root = updated_root
            self.layers_obj.adjacents_handler.root = updated_root
            # --- Кінець змін --- #
            # 1. Оновлюємо шари "Вузли" та "Полілінії", оскільки могли бути додані нові елементи.
            log_msg(logFile, "Оновлення шарів 'Вузли' та 'Полілінії'...")
            self.layers_obj.points_handler.redraw_pickets_layer()
            self.layers_obj.lines_handler.redraw_lines_layer()

            # --- Початок змін: Логування стану дерева ---
            adj_units_before_redraw = self.current_xml.tree.find(".//AdjacentUnits")
            if adj_units_before_redraw is None:
                log_msg(logFile, "(перед перемалюванням шару суміжників): Розділ 'AdjacentUnits' ВІДСУТНІЙ.")
            else:
                count = len(adj_units_before_redraw.findall("AdjacentUnitInfo"))
                log_msg(logFile, f"(перед перемалюванням шару суміжників): Розділ 'AdjacentUnits' ІСНУЄ. Кількість суміжників: {count}.")
            # --- Кінець змін ---
            # 2. Оновлюємо шар "Суміжники".
            log_msg(logFile, "Оновлення шару 'Суміжники'...")
            # add_adjacents_layer тепер сам видалить старий шар і створить новий,
            # заповнений актуальними даними. Це надійно.
            self.layers_obj.adjacents_handler.add_adjacents_layer()

        # --- Початок змін: Переміщення оновлення дерева в кінець ---
        # 3. Оновлюємо вигляд дерева та позначаємо зміни ПІСЛЯ оновлення шарів.
        self.current_xml.tree_view.rebuild_tree_view()
        self.mark_as_changed()
        # --- Кінець змін ---
        # self.iface.messageBar().pushMessage("Успіх", f"Суміжника додано до групи '{self.current_xml.group_name}'.", level=Qgis.Success, duration=5)

        # 4. Зберегти тимчасову копію для можливого відкату
        if not hasattr(self.current_xml, 'temp_tree_state') or self.current_xml.temp_tree_state is None:
            # self.iface.messageBar().pushMessage(
            #     "Інформація", "Нового суміжника було додано. Збережіть зміни, щоб оновити XML.",
            #     level=Qgis.Info, duration=5
            # )
            original_tree = etree.parse(self.current_xml.path)
            self.current_xml.temp_tree_state = original_tree

    def get_polyline_lengths(self, tree):
        """
        Повертає словник з довжинами поліліній.
        Ключ - ULID, значення - довжина.
        """
        lengths = {}
        for pl_element in tree.xpath(".//Polyline/PL"):
            ulid = pl_element.find("ULID").text
            length_element = pl_element.find("Length")
            if ulid and length_element is not None and length_element.text:
                try:
                    lengths[ulid] = float(length_element.text)
                except (ValueError, TypeError):
                    pass
        return lengths

    def calculate_total_line_length(self, tree):
        """Обчислює загальну довжину всіх ліній у XML-дереві."""
        total_length = 0.0
        for pl_element in tree.xpath(".//Polyline/PL"):
            length_element = pl_element.find("Length")
            if length_element is not None and length_element.text:
                try:
                    total_length += float(length_element.text)
                except (ValueError, TypeError):
                    pass
        return total_length

    def calculate_parcel_area(self, tree):
        """Обчислює площу ділянки з XML-дерева."""
        area_element = tree.find(".//ParcelMetricInfo/Area/Size")
        if area_element is not None and area_element.text:
            try:
                return float(area_element.text)
            except (ValueError, TypeError):
                pass
        return 0.0

    def on_picket_layer_editing_stopped(self, layer):
        """
        Обробляє сигнал editingStopped для шару 'Вузли'.
        Запитує користувача про збереження змін і виконує збереження/перемалювання.
        """
        # QMessageBox.information(
        #     self.iface.mainWindow(),
        #     "Сигнал: editingStopped",
        #     f"Зупинено редагування шару: '{layer.name()}'"
        # )
        committed = not layer.isModified()
        log_msg(logFile, f"editingStopped для шару '{layer.name()}', committed: {committed}")

        xml_data = self.find_xml_data_for_layer(layer)
        if not xml_data or not hasattr(xml_data, 'changed') or not xml_data.changed:
            return

        from .validators import compute_parcel_area

        # --- Початок змін: Надійне збереження стану перед редагуванням ---
        # Якщо тимчасовий стан не було створено (редагування почалося без додавання суміжника),
        # створюємо його зараз зі стану файлу на диску.
        if not hasattr(xml_data, 'temp_tree_state') or xml_data.temp_tree_state is None:
            xml_data.temp_tree_state = etree.parse(xml_data.path)
            log_msg(logFile, "Створено тимчасовий стан дерева (temp_tree_state) для відстеження змін геометрії.")
        # --- Кінець змін ---
        
        # --- Початок змін: Автоматичне збереження без діалогу ---
        if committed:
            # Зміни було застосовано. Автоматично зберігаємо їх.
            try:
                self.recalculate_parcel_area(xml_data.tree)
                xml_data.tree.write(xml_data.path, encoding="utf-8", xml_declaration=True)
                log_msg(logFile, f"Зміни геометрії збережено у файл: {xml_data.path}")
                # Оновлюємо залежні шари
                # QTimer.singleShot(0, lambda: self.update_geometry_dependent_layers(xml_data))
                self.iface.messageBar().pushMessage("Диск:", f"Зміни геометрії збережено та шари оновлено для {os.path.basename(xml_data.path)}", level=Qgis.Success, duration=5)
            except Exception as e:
                log_msg(logFile, f"Помилка при збереженні файлу: {e}")
                self.iface.messageBar().pushMessage("Помилка", f"Не вдалося зберегти зміни: {e}", level=Qgis.Critical)
        # --- Кінець змін ---
        else: # Changes were discarded by user in QGIS
            log_msg(logFile, f"Зміни для '{xml_data.group_name}' відкинуто користувачем. Відновлюємо попередній стан.")
            if hasattr(xml_data, 'temp_tree_state') and xml_data.temp_tree_state is not None:
                xml_data.tree = xml_data.temp_tree_state # Revert to the state before editing
            # --- Початок змін: Заміна руйнівного redraw_layers на безпечне оновлення ---
            QTimer.singleShot(0, lambda: self.update_geometry_dependent_layers(xml_data)) # Redraw layers to match the reverted state
            # --- Кінець змін ---

        # Reset the changed flag and temp state
        xml_data.changed = False
        xml_data.temp_tree_state = None

    def handle_committed_features_removed(self, layer, feature_ids):
        """Обробляє подію ПІСЛЯ видалення об'єктів з шару 'Суміжники'."""
        layer_name = layer.name()
        if layer_name != "Суміжники":
            return

        xml_data = self.find_xml_data_for_layer(layer)
        if not xml_data:
            return
        
        log_msg(logFile, f"Видалено {len(feature_ids)} об'єкт(ів) з шару '{layer_name}'. Початок синхронізації з XML.")

        # 1. Отримуємо object_shape всіх об'єктів, що ЗАЛИШИЛИСЯ на шарі
        processor = GeometryProcessor(xml_data.tree)
        remaining_shapes = set()
        for feature in layer.getFeatures():
            shape = processor.get_shape_from_qgis_feature(feature)
            if shape:
                remaining_shapes.add(shape)

        # 2. Визначаємо, які елементи видалити з XML
        all_xml_adj_units = xml_data.tree.findall(".//AdjacentUnitInfo")
        adj_units_to_delete = []

        for adj_unit in all_xml_adj_units:
            lines_container = adj_unit.find('AdjacentBoundary/Lines')
            shape = processor._get_polyline_object_shape(lines_container)
            # Якщо shape з XML не знайдено серед тих, що залишились на карті,
            # цей елемент є кандидатом на видалення.
            if shape not in remaining_shapes:
                log_msg(logFile, f"Визначено суміжника до видалення з XML. Shape: '{shape}'.")
                adj_units_to_delete.append(adj_unit)

        if adj_units_to_delete:
            # 3. Видаляємо елементи <AdjacentUnitInfo> з дерева
            adj_container = xml_data.tree.find(".//AdjacentUnits")
            if adj_container is not None:
                for unit in adj_units_to_delete:
                    adj_container.remove(unit)
            # 4. Запускаємо очищення "осиротілої" геометрії
            processor.cleanup_geometry(adj_units_to_delete)

            # Оновлюємо дерево та позначаємо зміни
            # --- Початок змін: Перенумерація геометрії --- #
            # processor.renumber_geometry() # Цей виклик тепер всередині cleanup_geometry
            # log_msg(logFile, "Геометрію (вузли та лінії) було перенумеровано.") #
            # --- Кінець змін --- #
            xml_data.tree_view.rebuild_tree_view()
            self.mark_as_changed()

            # Зберігаємо зміни автоматично
            try:
                xml_data.tree_view.save_xml_tree(xml_data.tree, xml_data.path)
                log_msg(logFile, f"Зміни (видалення суміжників) збережено у файл: {xml_data.path}")
                # Скидаємо прапорець змін після збереження
                xml_data.changed = False
                self.update_tab_style_by_group_name(xml_data.group_name, is_changed=False)
                self.update_changed_actions_state(is_changed=False)
            except Exception as e:
                log_msg(logFile, f"Помилка при автоматичному збереженні після видалення суміжників: {e}")

    def delete_adjacent_from_map(self, xml_element_to_delete):
        """
        Видаляє відповідний графічний об'єкт з шару 'Суміжники' на карті,
        коли вузол 'AdjacentUnitInfo' видаляється з дерева XML.
        """
        if self.current_xml is None or xml_element_to_delete.tag != 'AdjacentUnitInfo':
            return

        log_msg(logFile, "Запущено видалення суміжника з карти, синхронізоване з XML-деревом.")

        # 1. Обчислюємо object_shape для XML-елемента, що видаляється
        processor = GeometryProcessor(self.current_xml.tree)
        shape_to_delete = processor._get_polyline_object_shape(xml_element_to_delete.find('AdjacentBoundary/Lines'))

        if not shape_to_delete:
            log_msg(logFile, "Не вдалося обчислити object_shape для суміжника, що видаляється з XML.")
            return

        # 2. Знаходимо шар 'Суміжники'
        group = QgsProject.instance().layerTreeRoot().findGroup(self.current_xml.group_name)
        if not group:
            return

        adj_layer = None
        for child in group.children():
            if child.name() == "Суміжники":
                adj_layer = child.layer()
                break
        
        if not adj_layer:
            log_msg(logFile, "Шар 'Суміжники' не знайдено на карті.")
            return

        # 3. Шукаємо та видаляємо відповідний об'єкт на шарі
        feature_to_delete_id = -1
        for feature in adj_layer.getFeatures():
            geom = feature.geometry()
            polyline_points = geom.asPolyline()
            shape_uidps = [processor.find_point_uidp(p) for p in polyline_points if processor.find_point_uidp(p)]
            current_shape = "-".join(shape_uidps)

            if current_shape == shape_to_delete:
                feature_to_delete_id = feature.id()
                adj_layer.startEditing()
                adj_layer.deleteFeature(feature_to_delete_id)
                adj_layer.commitChanges()
                log_msg(logFile, f"Об'єкт суміжника {shape_to_delete} було видалено з шару 'Суміжники'.")
                break

    def find_xml_data_for_layer(self, layer):
        """
        Знаходить об'єкт xml_data, до якого належить вказаний шар.

        Призначення:
        Ця функція є ключовою для синхронізації між шарами QGIS та відповідними
        XML-файлами, відкритими у плагіні. Коли відбувається якась дія з шаром
        (наприклад, видалення об'єкта або зміна геометрії), плагіну потрібно
        знати, який саме XML-файл слід оновити.

        Механізм роботи:
        При створенні групи шарів для кожного XML-файлу, на кожен шар цієї групи
        встановлюється спеціальна властивість (custom property) з назвою
        "xml_data_object_id". Значенням цієї властивості є унікальний ідентифікатор
        (ID) об'єкта `xml_data` в пам'яті.

        Ця функція зчитує цей ID з шару, а потім шукає у списку всіх відкритих
        XML-файлів (`self.opened_xmls`) об'єкт `xml_data` з таким самим ID.

        Args:
            layer (QgsVectorLayer): Шар QGIS, для якого потрібно знайти
                                    відповідний об'єкт `xml_data`.

        Returns:
            xml_data or None: Повертає знайдений об'єкт `xml_data` або `None`,
                              якщо відповідність не знайдено.

        Звідки викликається:
        - `on_layer_will_be_removed`: Щоб визначити, який XML-файл потрібно змінити, коли шар видаляється з проекту.
        - `update_xml_from_geometry_change`: Щоб оновити координати в правильному XML при переміщенні вузла на карті.
        - `handle_committed_features_removed`: Щоб видалити відповідні елементи з XML, коли об'єкти видаляються з шару.

        Що логує:
        - Повідомлення, якщо вхідний шар є `None`.
        - Повідомлення про успішне знаходження `xml_data` через custom property.
        - Попередження, якщо шар має ID, але відповідний об'єкт `xml_data` не знайдено у списку `opened_xmls` (може свідчити про розсинхронізацію стану).
        - Повідомлення, якщо шар не має необхідної властивості `xml_data_object_id`.
        """
        if not layer:
            log_msg(logFile, "find_xml_data_for_layer: Вхідний шар є None.")
            return None

        xml_data_object_id = layer.customProperty("xml_data_object_id")
        if xml_data_object_id is not None:
            for xml_data in self.opened_xmls:

                if id(xml_data) == int(xml_data_object_id):
                    log_msg(logFile, f"Знайдено xml_data для шару '{layer.name()}' через custom property.")
                    return xml_data
            log_msg(logFile, f"ID {str(xml_data_object_id)[-4]} '{layer.name()}', але xml_data об'єкт не знайдено в opened_xmls.")
        else:
            log_msg(logFile, f"Шар '{layer.name()}' не має custom property 'xml_data_object_id'.")

        return None 


    def recalculate_parcel_area(self, tree):
        """Перераховує та оновлює площу ділянки в XML-дереві."""
        from .validators import compute_parcel_area
        try:
            area_m2 = compute_parcel_area(tree)
            area_ha = area_m2 / 10000.0

            area_element = tree.find(".//ParcelMetricInfo/Area/Size")
            if area_element is not None:
                area_element.text = f"{area_ha:.4f}"
                log_msg(logFile, f"Оновлено площу ділянки в XML до {area_ha:.4f} га.")
            else:
                log_msg(logFile, "Елемент 'Size' для площі не знайдено в XML.")
        except Exception as e:
            log_msg(logFile, f"Помилка при перерахунку площі ділянки: {e}")


    def recalculate_line_lengths(self, tree, changed_point_uidp):
        """Перераховує довжини всіх ліній, які містять змінену точку."""
        log_msg(logFile, f"Перерахунок довжин ліній для точки UIDP='{changed_point_uidp}'.")

        # Знаходимо всі лінії, що містять точку
        lines_to_update = tree.xpath(f".//Polyline/PL[Points/P='{changed_point_uidp}']")

        for pl_element in lines_to_update:
            point_refs = pl_element.findall("Points/P")
            if len(point_refs) != 2:
                continue

            p1_uidp = point_refs[0].text
            p2_uidp = point_refs[1].text

            # Отримуємо координати точок з XML
            p1_elem = tree.find(f".//PointInfo/Point[UIDP='{p1_uidp}']")
            p2_elem = tree.find(f".//PointInfo/Point[UIDP='{p2_uidp}']")

            if p1_elem is not None and p2_elem is not None:
                try:
                    # Пам'ятаємо, що в XML X та Y поміняні місцями відносно QGIS
                    x1, y1 = float(p1_elem.find("Y").text), float(p1_elem.find("X").text)
                    x2, y2 = float(p2_elem.find("Y").text), float(p2_elem.find("X").text)

                    length = ((x2 - x1)**2 + (y2 - y1)**2)**0.5

                    length_element = pl_element.find("Length")
                    length_element.text = f"{length:.2f}"
                    ulid = pl_element.find("ULID").text
                    log_msg(logFile, f"Оновлено довжину для лінії ULID='{ulid}' до {length:.2f} м.")
                except (ValueError, TypeError) as e:
                    log_msg(logFile, f"Помилка при перерахунку довжини: {e}")


    def redraw_layers(self, xml_data):
        """Перемальовує шари для даного XML, зберігаючи існуючу групу."""
        log_msg(logFile, f"Повне перемалювання шарів для групи '{xml_data.group_name}'.")
        layers_root = QgsProject.instance().layerTreeRoot()
        group = layers_root.findGroup(xml_data.group_name)
        if not group:
            log_msg(logFile, f"Група '{xml_data.group_name}' не знайдена для перемалювання.")
            return

        # 1. Видаляємо всі дочірні вузли з групи
        group.removeChildren(0, len(group.children()))
        log_msg(logFile, f"Очищено групу '{xml_data.group_name}'.")

        # 2. Знаходимо та видаляємо "осиротілі" шари з проекту
        project = QgsProject.instance()
        layer_ids_to_remove = []
        for layer_id, layer in project.mapLayers().items():
            # Якщо шар більше не існує в дереві шарів, він "осиротів"
            if project.layerTreeRoot().findLayer(layer_id) is None:
                layer_ids_to_remove.append(layer_id)

        if layer_ids_to_remove:
            project.removeMapLayers(layer_ids_to_remove)
            log_msg(logFile, f"Видалено {len(layer_ids_to_remove)} осиротілих шарів з проекту.")

        # 3. Створюємо новий екземпляр xmlUaLayers.
        # Він знайде існуючу (тепер порожню) групу за іменем і заповнить її новими шарами.
        self.layers_obj = xmlUaLayers(
            xmlFilePath=xml_data.path, 
            tree=xml_data.tree,
            plugin=self.plugin,
            xml_data=xml_data  # Передаємо xml_data для збереження зв'язку
        )

        log_msg(logFile, f"Шари для групи '{xml_data.group_name}' успішно перемальовано.")

    def redraw_specific_layer(self, xml_data, layer_name):
        """
        Перемальовує конкретний шар у групі, не зачіпаючи інші.
        """
        log_msg(logFile, f"Перемалювання шару '{layer_name}' для групи '{xml_data.group_name}'.") # type: ignore

        group = QgsProject.instance().layerTreeRoot().findGroup(xml_data.group_name)
        if not group:
            log_msg(logFile, f"Група '{xml_data.group_name}' не знайдена.")
            return

        # Знаходимо існуючий шар
        existing_layer = None
        for child in group.children():
            if isinstance(child, QgsLayerTreeLayer) and child.name() == layer_name:
                existing_layer = child.layer()
                break

        if not existing_layer:
            log_msg(logFile, f"Шар '{layer_name}' не знайдено в групі для перемалювання.")
            return

        # Очищуємо шар від усіх фіч
        existing_layer.startEditing()
        existing_layer.deleteFeatures(existing_layer.allFeatureIds())
        existing_layer.commitChanges()

        if layer_name == "Угіддя":
            self._fill_lands_layer(existing_layer, xml_data)
        elif layer_name == "Суміжники":
            self._fill_adjacents_layer(existing_layer, xml_data)

        log_msg(logFile, f"Шар '{layer_name}' успішно перемальовано.")



    def _fill_lands_layer(self, layer, xml_data):
        """
        Заповнює існуючий шар 'Угіддя' даними з XML.
        Використовується для оновлення шару без його повного видалення та створення.
        """
        provider = layer.dataProvider()
        layer.startEditing()
        # --- Початок змін: Виправлення AttributeError ---
        # Створюємо тимчасовий об'єкт для доступу до методу _coord_to_polygon, оскільки він не є статичним
        from .lands import LandsParcels
        lands_handler = LandsParcels(xml_data.tree.getroot(), self.iface.mapCanvas().mapSettings().destinationCrs().authid(), self.layers_obj.group, self.layers_obj.plugin_dir, QgsProject.instance().layerTreeRoot(), self.layers_obj.linesToCoordinates, self.layers_obj)
        # --- Кінець змін ---

        root = xml_data.tree.getroot()

        # --- Початок змін: Примусове оновлення кешу геометрії ---
        # Перед будь-яким перемалюванням шару, ми повинні оновити внутрішні
        # кеші (словники) точок та ліній в об'єкті layers_obj. Це гарантує,
        # що вони міститимуть нові елементи, щойно додані до XML-дерева
        # (наприклад, при додаванні угіддя з отвором).
        self.layers_obj.points_handler.read_points()
        self.layers_obj.lines_handler.read_lines()
        # --- Кінець змін ---
        lines_to_coords_func = self.layers_obj.linesToCoordinates

        for lands_parcel in root.findall(".//LandsParcel/LandParcelInfo/MetricInfo"):
            cadastral_code = lands_parcel.findtext("../CadastralCode")
            land_code = lands_parcel.findtext("../LandCode")
            size_element = lands_parcel.find("./Area/Size")
            size = float(size_element.text) if size_element is not None and size_element.text else None

            externals_lines = lands_parcel.find(".//Externals/Boundary/Lines")
            external_coords = lines_to_coords_func(externals_lines) if externals_lines is not None else []

            internals_lines = lands_parcel.find(".//Internals/Boundary/Lines")
            internal_coords_list = [lines_to_coords_func(b.find('Lines')) for b in lands_parcel.findall(".//Internals/Boundary")]

            polygon = lands_handler._coord_to_polygon(external_coords)
            for internal_coords in internal_coords_list:
                if internal_coords:
                    polygon.addInteriorRing(lands_handler._coord_to_polygon(internal_coords).exteriorRing())

            feature = QgsFeature(layer.fields())
            feature.setGeometry(QgsGeometry(polygon))
            feature.setAttributes([cadastral_code, land_code, size])
            provider.addFeature(feature)

        layer.commitChanges()
        log_msg(logFile, f"Шар '{layer.name()}' було оновлено даними з XML.")

    def _fill_adjacents_layer(self, layer, xml_data):
        """
        Заповнює існуючий шар 'Суміжники' даними з XML.
        """
        provider = layer.dataProvider()
        layer.startEditing()

        from .adjacents import AdjacentUnits
        adjacents_handler = AdjacentUnits(
            xml_data.tree.getroot(),
            self.iface.mapCanvas().mapSettings().destinationCrs().authid(),
            self.layers_obj.group,
            self.layers_obj.plugin_dir,
            self.layers_obj,
            xml_data=xml_data
        )

        root = xml_data.tree.getroot()
        adjacents_parent = root.find(".//AdjacentUnits")
        if adjacents_parent is None:
            layer.commitChanges()
            return

        for adjacent in adjacents_parent.findall(".//AdjacentUnitInfo"):
            cadastral_number = adjacent.findtext(".//CadastralNumber")
            proprietor = adjacents_handler._get_proprietor_name(adjacent)
            boundary_element = adjacent.find(".//AdjacentBoundary/Lines")
            if boundary_element is not None:
                boundary_coords = self.layers_obj.lines_element2polyline(boundary_element)
                if boundary_coords and len(boundary_coords) >= 2:
                    line_string = QgsLineString([QgsPointXY(p.y(), p.x()) for p in boundary_coords])
                    feature = QgsFeature(layer.fields())
                    feature.setGeometry(QgsGeometry(line_string))
                    feature.setAttributes([cadastral_number, proprietor])
                    provider.addFeature(feature)
        layer.commitChanges()

    def update_geometry_dependent_layers(self, xml_data):
        """
        Безпечно оновлює шари, що залежать від геометрії (Вузли, Полілінії, Суміжники),
        не зачіпаючи інші шари.
        """
        if not xml_data or not self.layers_obj:
            log_msg(logFile, "Немає даних для оновлення шарів, що залежать від геометрії.")
            return

        log_msg(logFile, f"Запуск безпечного оновлення шарів для групи '{xml_data.group_name}'.")

        # 1. Оновлюємо шари "Вузли" та "Полілінії"
        self.layers_obj.points_handler.redraw_pickets_layer()
        self.layers_obj.lines_handler.redraw_lines_layer()

        # 2. Оновлюємо шар "Суміжники"
        from .adjacents import AdjacentUnits
        group = QgsProject.instance().layerTreeRoot().findGroup(xml_data.group_name)
        if not group:
            return

        layer_name = "Суміжники"

        # Перевіряємо, чи є взагалі розділ AdjacentUnits в XML
        if xml_data.tree.find(".//AdjacentUnits") is not None:
            # Створюємо екземпляр обробника
            adjacents_handler = AdjacentUnits(
                root=xml_data.tree.getroot(),
                crs_epsg=self.iface.mapCanvas().mapSettings().destinationCrs().authid(),
                group=group,
                plugin_dir=self.plugin.plugin_dir,
                xml_ua_layers_instance=self.layers_obj,
                xml_data=xml_data
            )
            # add_adjacents_layer тепер сам видалить старий шар і створить новий,
            # заповнений актуальними даними. Це надійно.
            adjacents_handler.add_adjacents_layer()
            log_msg(logFile, f"Шар '{layer_name}' було оновлено/створено.")

    # def customize_layer_tree_context_menu(self, point):
    #     """
    #     Customizes the layerTreeView context menu, removing or disabling the "Rename Group" item.
    #     """
    #     log_calls(logFile, f"point = {point}")
    #     QMessageBox.information(self, "customize_layer_tree_context_menu()", f"point = {point}")


    #     try:
    #         # Get the layerTreeView
    #         layer_tree_view = self.iface.layerTreeView()

    #         # Get the index of the item where the right-click occurred
    #         index = layer_tree_view.indexAt(point)

    #         # Check if the click was on a valid item
    #         if not index.isValid():
    #             return

    #         # Get the layer tree model
    #         model = layer_tree_view.model()

    #         # Get the layer tree node
    #         node = model.nodeFromIndex(index)

    #         # Create a new context menu
    #         menu = QMenu()

    #         # Add the default actions to the menu
    #         actions = layer_tree_view.contextMenuActions(index)
    #         for action in actions:
    #             menu.addAction(action)

    #         # Remove or disable the "Rename Group" item
    #         for action in menu.actions():
    #             if action.text() == "Перейменувати групу":  # "Rename Group" in Ukrainian
    #                 if isinstance(node, QgsLayerTreeGroup):
    #                     # Remove the menu item
    #                     menu.removeAction(action)
    #                     # Or disable the menu item:
    #                     # action.setEnabled(False)
    #                 break

    #         # Show the menu
    #         menu.exec_(layer_tree_view.mapToGlobal(point))

    #     except Exception as e:
    #         log_calls(logFile, f"Error customizing context menu: {e}")
