# -*- coding: utf-8 -*-
"""
/***************************************************************************
 xml_uaDockWidget
                                 A QGIS plugin
 Processing ukrainian cadastral files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-01
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Mike
        email                : michael.krechkivski@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import inspect
import uuid

from qgis.PyQt import uic

from qgis.PyQt.QtGui import QIcon

from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtCore import QModelIndex
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtCore import QDate

from qgis.core import Qgis

from qgis.PyQt.QtWidgets import QDockWidget
from qgis.PyQt.QtWidgets import QWidget
from qgis.PyQt.QtWidgets import QVBoxLayout
from qgis.PyQt.QtWidgets import QHBoxLayout
from qgis.PyQt.QtWidgets import QMenu
from qgis.PyQt.QtWidgets import QAction
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.PyQt.QtWidgets import QToolButton
from qgis.PyQt.QtWidgets import QStyle
from qgis.PyQt.QtWidgets import QTreeView
from qgis.PyQt.QtWidgets import QFileDialog
from qgis.PyQt.QtWidgets import QInputDialog
from qgis.PyQt.QtWidgets import QTableView
from qgis.PyQt.QtWidgets import QDialog

from .tree_view import CustomTreeView
from .table_view import TableViewMetadata
from .layers import xmlUaLayers

from .common import logFile
from .common import log_msg
from .common import xsd_path
from .common import config


FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'xml_ua_dockwidget_base.ui'))

class xml_uaDockWidget(QDockWidget, FORM_CLASS):
    """ Клас віджета
        Базові класи:
            QDockWidget
            FORM_CLASS
        Атрибути:
            tabXML
            treeViewXML
            tabMetadata
            tableViewMetadata
            tooltips підказки для рядків 0-6 (ServiceInfo)
    """
    closingPlugin = pyqtSignal()

    def __init__(self, parent):
        """ Конструктор

            Встановлює обробники подій для tableViewMetadata
            Але не для treeViewXML
            
            Аргумент
                self: Вказівник на екземпляр класу
                parent: Вказівник на екземпляр батьківського класу
                xsd_path
        """
        # log_msg(logFile, f"parent = {parent}")

        super().__init__()
        self.setupUi(self)
        self.xsd_path = xsd_path
        self.parent = parent

        # Дерево XML
        old_tree_view = self.findChild(QTreeView, "treeViewXML")
        self.treeViewXML = CustomTreeView(parent = self)
        if old_tree_view:
            layout = self.tabXML.layout()
            if layout:
                layout.removeWidget(old_tree_view)
            old_tree_view.setParent(None)
            old_tree_view.deleteLater()
        self.treeViewXML.setObjectName("treeViewXML")  # Залишаємо те саме ім'я
        self.tabXML.layout().addWidget(self.treeViewXML)  # Додаємо до layout

        # Таблиця метаданих
        old_table_view = self.findChild(QTableView, "tableViewMetadata")
        if old_table_view:
            # Видаляємо старий-UI віджет із менеджера компоновки
            layout = self.tabMetadata.layout()
            if layout:
                layout.removeWidget(old_table_view)
            # Від'єднати й знищити
            old_table_view.setParent(None)
            old_table_view.deleteLater()
        # Передаємо у таблицю self, який є QDockWidget, як parent
        self.tableViewMetadata = TableViewMetadata(self)
        self.tableViewMetadata.setObjectName("tableViewMetadata")  # Залишаємо те саме ім'я
        self.tabMetadata.layout().addWidget(self.tableViewMetadata)  # Додаємо до layout

        # Виклик функцій для додавання меню
        self.add_menu_buttons()

    def load_data(self, xml_path):
        """
            Викликає функції завантаження:
                -  XML у віджет дерева
                -  метаданих у віджет таблиці (тимчасово:)
        """
        # log_msg(logFile, "Виклик функцій завантаження даних у дерево і таблицю")
        self.treeViewXML.load_xml_to_tree_view(xml_path, xsd_path)
        self.tableViewMetadata.populate_tableview_metadata(self.treeViewXML.xml_tree)

    def on_tree_data_changed(self, path, value):
        """
        Оновлення tableViewMetadata при зміні даних у treeViewXML.
        """
        # log_msg(logFile, f"value = {value}")
        metadata_model = self.tableViewMetadata.model()
        # log_msg(logFile, f"metadata_model = {metadata_model}")
        if not metadata_model:
            log_msg(logFile, "metadata_model is None")
            return
        # log_msg(logFile, "metadata_model is NOT None")
        # log_msg(logFile, f"metadata_model.rowCount() = {metadata_model.rowCount()}")

        for row in range(metadata_model.rowCount()):
            # log_msg(logFile, f"item({row}, 1)")
            key_item = metadata_model.item(row, 0)
            if key_item and key_item.text() == path:
                value_item = metadata_model.item(row, 1)
                value_item.setText(value)
                # log_msg(logFile, f"item({row}, 1)")
                break

    def closeEvent(self, event):
        """ Логування при закритті плагіну"""
        log_msg(logFile)
        self.closingPlugin.emit()
        event.accept()

    def add_menu_buttons(self):
        """
        Додає дві кнопки з випадаючими меню в основний інтерфейс QDockWidget,
        включаючи стандартні іконки Qt і користувацьку іконку для дії перевірки синтаксису.
        """
        # log_msg(logFile, "Додавання кнопок меню")
        # Створюємо перше меню з іконками
        menu1 = QMenu("Меню 1", self)

        # Стандартні дії з іконками
        action_new = QAction(self.style().standardIcon(QStyle.SP_FileIcon), "Новий", self)
        action_open = QAction(self.style().standardIcon(QStyle.SP_DirOpenIcon), "Відкрити", self)
        action_save = QAction(self.style().standardIcon(QStyle.SP_DialogSaveButton), "Зберегти", self)
        action_save_as = QAction(self.style().standardIcon(QStyle.SP_DialogSaveButton), "Зберегти як...", self)

        # Додавання користувацької іконки для дії перевірки синтаксису
        custom_icon_path = os.path.dirname(__file__) + "/images/check32x32.png"  # Задайте шлях до іконки
        action_check = QAction(QIcon(custom_icon_path), "Перевірити", self)

        # Додаємо дії до меню
        menu1.addAction(action_new)
        menu1.addAction(action_open)
        menu1.addAction(action_save)
        menu1.addAction(action_save_as)

        # Додаємо горизонтальний розділювач
        menu1.addSeparator()

        # Додаємо дію перевірки синтаксису з користувацькою іконкою
        menu1.addAction(action_check)

        # Створюємо першу кнопку меню
        menu_button1 = QToolButton(self)
        menu_button1.setText("Файл")  # Іконка або текст для кнопки
        menu_button1.setMenu(menu1)
        menu_button1.setPopupMode(QToolButton.InstantPopup)
        menu_button1.setFixedSize(44, 24)  # Обмеження розміру кнопки

        # Створюємо друге меню для довідкових дій
        menu2 = QMenu("Меню 2", self)
        action_help = QAction(self.style().standardIcon(QStyle.SP_MessageBoxQuestion), "Допомога", self)
        action_about = QAction(self.style().standardIcon(QStyle.SP_MessageBoxInformation), "Про програму", self)

        # Додаємо дії до другого меню
        menu2.addAction(action_help)
        menu2.addAction(action_about)

        # Створюємо другу кнопку меню
        menu_button2 = QToolButton(self)
        menu_button2.setText("Допомога")  # Іконка або текст для кнопки
        menu_button2.setMenu(menu2)
        menu_button2.setPopupMode(QToolButton.InstantPopup)
        menu_button2.setFixedSize(64, 24)  # Обмеження розміру кнопки

        # Створюємо контейнерний віджет для кнопок і горизонтальний макет
        button_container = QWidget(self)
        button_container.setMinimumWidth(150)
        button_layout = QHBoxLayout(button_container)
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_layout.addWidget(menu_button1)
        button_layout.addWidget(menu_button2)
        button_layout.addStretch()  # Додаємо розтягнення для вирівнювання кнопок ліворуч

        # Основний макет для QDockWidget
        main_layout = QVBoxLayout(self)
        main_layout.addWidget(button_container)
        main_layout.addStretch()  # Відступ знизу, щоб кнопки залишались зверху
        self.setLayout(main_layout)

        # Підключення обробників дій
        action_new.triggered.connect(lambda: print("Створено новий документ"))
        action_open.triggered.connect(self.process_action_open)
        action_save.triggered.connect(self.process_action_save)
        action_save_as.triggered.connect(self.process_action_save_as)
        action_check.triggered.connect(self.process_action_check)
        action_help.triggered.connect(lambda: print("Допомога"))
        action_about.triggered.connect(lambda: print("Про програму"))

    def process_action_check(self):
        """ """
        log_msg(logFile, "Обробка події перевірки файлу XML")


        
        # level= Qgis.Success, Qgis.MessageLevel, Qgis.Info, Qgis.Warning, Qgis.Critical
        # duration sec 0 - до закриття
        self.parent.iface.messageBar().pushMessage("xml_ua:", "Обробка події перевірки файлу XML", level=Qgis.Success, duration=0)
        QMessageBox.warning(self, "xml_ua:", "Вихід")
        self.handle_error_and_close("Обробка події перевірки файлу XML")

    def process_action_open(self, xsd_path):
        """ """
        # log_msg(logFile, "Обробка події відкриття файлу XML")
        xml_path, _ = QFileDialog.getOpenFileName(self, "Відкрити XML файл", "", "XML файли (*.xml)")

        if not xml_path:
            QMessageBox.warning(self, "Помилка", "Файл не вибрано.")
            return

        # xml_file_name = os.path.basename(xml_path)

        # self.load_data(xml_path, self.xsd_path)
        self.load_data(xml_path)


        self.treeViewXML.expand_initial_elements()
        self.treeViewXML.set_column_width(0, 75)

        projectLayers = xmlUaLayers(xml_path)

        return

    def process_action_save(self):

        # log_msg(logFile)

        frame = inspect.currentframe()
        # log_object(logFile, self, frame, 'treeViewXML')

        folder_path = QFileDialog.getExistingDirectory(None, "Виберіть папку для збереження")

        if folder_path:
            # Додаємо ім'я файлу до обраного шляху
            full_path = f"{folder_path}/{xml_file_name}"
            QMessageBox.information(None, "Шлях для збереження", f"Файл буде збережено як: {full_path}")
            save_tree_view_to_xml(self.treeViewXML, full_path)
            return
        else:
            # Якщо користувач скасував вибір
            QMessageBox.warning(None, "Відміна", "Папка не вибрана.")
            return None

    def process_action_save_as(self):
        global treeViewXml
        global xmlPath

        log_msg(logFile)
        folder_path = QFileDialog.getExistingDirectory(self, "Виберіть папку для збереження")
        if not folder_path:
            QMessageBox.warning(self, "Помилка", "Папку не вибрано.")
            return

        save_path = os.path.join(folder_path, "збережений_файл.xml")
        self.treeViewXML.save_tree_view_to_xml(save_path)
        QMessageBox.information(self, "Успіх", f"Файл збережено: {save_path}")

    def get_tooltip_from_tree(self, full_path, default_name):
        """
        Отримує tooltip для елемента з дерева за його шляхом.
        Якщо tooltip не знайдено, повертає default_name.
        """
        # log_msg(logFile)  # recursion
        tree_index = self.find_element_index(path=full_path)  # Пошук елемента за шляхом
        if tree_index.isValid():
            tree_item = self.treeViewXML.model.itemFromIndex(tree_index)
            if tree_item:
                return tree_item.toolTip() or default_name  # Повертає tooltip або default_name

        return default_name

    def find_element_index(self, path=None, element_name=None):
        """
        Знаходить індекс елемента у дереві на основі шляху або імені.
        """
        # log_msg(logFile) # recursion
        if path:
            # Логіка пошуку за шляхом
            current_index = QModelIndex()
            path_parts = path.split("/")  # Розділяємо шлях на частини
            for part in path_parts:
                found = False
                for row in range(self.treeViewXML.model.rowCount(current_index)):
                    child_index = self.treeViewXML.model.index(row, 0, current_index)
                    child_item = self.treeViewXML.model.itemFromIndex(child_index)
                    if child_item and child_item.text() == part:
                        # Переходимо на наступний рівень дерева
                        current_index = child_index
                        found = True
                        break
                if not found:
                    # Якщо будь-яка частина шляху не знайдена, повертаємо пустий індекс
                    return QModelIndex()
            return current_index
        elif element_name:
            # Логіка пошуку за іменем
            for row in range(self.treeViewXML.model.rowCount()):
                item = self.treeViewXML.model.item(row, 0)  # Припустимо, імена у першій колонці
                if item and item.text() == element_name:
                    return self.treeViewXML.model.indexFromItem(item)
        return QModelIndex()

    def handle_error_and_close(self, error_message):
        """
        Обробляє помилку, відображає повідомлення і закриває док-віджет.

        :param error_message: Текст повідомлення про помилку.
        """
        # Відображення повідомлення про помилку
        self.parent.iface.messageBar().pushCritical("Помилка", error_message)
        self.close()
